#### 28. Определение операционной системы (ОС). Место ОС в программном обеспечении компьютеров, компьютерных систем и сетей. Тенденции и перспективы развития операционных систем и сред.

**Операционная система** — это набор программ, который управляет аппаратными средствами компьютера и предоставляет среду для выполнения программ. ОС служит мостом между пользователем и компьютером, обеспечивая ресурсы для программ, управление файлами, памятью, процессами и многозадачностью.

##### Место ОС

В обеспечении компьютеров ОС играет важную роль, ведь она предоставляет интерфейс для взаимодействия пользователя, обеспечивает эффективное взаимодействие аппаратных частей компьютера и многое другое.

В компьютерных системах ОС обеспечивает эффективное взаимодействие узлов системы и централизованное управление.

ОС также часто используются в компьютерных сетях. Примером могут послужить ОС маршрутизаторов, коммутаторов и других сетевых устройств. Или например веб-хостинги. На их серверах стоят ОС, которые позволяют эффективно отвечать на запросы клиентов. В конце концов ОС обычных компьютеров участвует в сетевом соединении, обрабатывает пакеты, управляет сетевыми интерфейсами и многое другое.

##### Тенденции и перспективы

Направлений для развития ОС можно увидеть бесконечное множество. В последние годы сильно развиваются ОС мобильных устройств и встраиваемых устройств (устройства умного дома). Перспективным является направление разработки ОС, у которых в приоритете находится безопасность. ОС для квантовых компьютеров. Интеграция ИИ в ОС.

#### 29. Назначение, состав и функции ОС. Понятие компьютерных ресурсов.

##### Основные назначения ОС:
- Управление аппаратными компонентами и из взаимодействием. Распределение этих ресурсов между пользователями и процессами.
- Абстракция. Предоставление удобного интерфейса для взаимодействия с компьютером для пользователя. Сюда же можно отнести предоставление удобных функций для разработчиков ПО.
- Обеспечение безопасности и сохранности данных.
- Обеспечение связи между компьютерами в сети.
- Планирование задач, многозадачность...

##### Состав ОС: (по Васильеву)
- Текстовый пользовательский интерфейс
- GUI
- Программные библиотеки
- Утилиты
- Пользовательские программы

##### Функции ОС:
- Выполнение программ.
- Управление файловой системой.
- Управление устройствами ввода/вывода.

##### Понятие компьютерных ресурсов

**Ресурсы** — средства, имеющиеся в наличии, но к которым обращаются лишь при необходимости.

Существует много видов компьютерных ресурсов: аппаратные, файловые, программные (совокупность установленных программ), ресурс памяти (как постоянной, так и виртуальной) и многие другие.

Например к аппаратным ресурсам относятся: CPU, RAM, HDD/SSD, сетевые интерфейсы, устройства ввода/вывода.

#### 30. Концепция многоуровневого виртуального компьютера. Операционные оболочки и среды.

**Многоуровневый виртуальный компьютер** — это система, где физический компьютер может запускать несколько виртуальных машин, а внутри каждой из них можно создать еще одну виртуальную машину. Это создает многоуровневую структуру, где каждый уровень работает независимо, как отдельный компьютер. Используются в областях тестирования, кибербезопасности.

**Операционная оболочка** — это программа, предоставляющая интерфейс для взаимодействия пользователя с функциями операционной системы. Это может быть как командная строка, так и графический интерфейс.

#### 31. Архитектуры операционных систем.

| Тип архитектуры | Краткое описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Монолитное ядро | Все основные функции ОС встроены прямо в ядро. Обладает высокой скоростью, но слабой отказоустойчивостью. Представителями являются большинство UNIX-систем. При обращении к ядру происходит смена контекста (user mode -> kernel mode), выполнение запроса и возвращение обратно к программе (kernel -> user).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Микроядро       | Ядро содержит только самые базовые функции (прерывания, процессы, планирование, межпроцессорное взаимодействие (IPC — Inter Process Communications), память). Остальное вынесено в отдельные процессы в пространстве пользователя. Такая система медленнее из-за постоянных переключений контекста (world switch). Но в то же время она надёжнее. Также такую систему проще расширять. Самыми яркими представителями являются MINIX и Mach (ядро Mac OS X). При обращении к ядру, происходит смена контекста (user -> kernel), микроядро переходит выполняет переход к службе, находящейся в пространстве пользователя (kernel -> user), запрос выполняется и управление снова передаётся микроядру (user -> kernel) и наконец происходит возвращение к вызвавшему процессу (kernel -> user). |
| Гибридное ядро  | Модифицированные микроядра, которые позволяют запускать "несущественные" части в пространстве пользователя. Представителями являются NT Kernel, BSD-основанные.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Модульное ядро  | Модульные ядра, в отличие от «классических» монолитных ядер, не требуют полной перекомпиляции ядра, если меняется оборудование компьютера. Вместо этого, они позволяют загружать нужные модули (например, драйвера) для работы с новым аппаратным обеспечением без необходимости переписывать всё ядро.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Наноядро        | Крайне упрощенное и минималистичное ядро выполняет лишь обработку аппаратных прерываний. После этого оно посылает информацию о результатах обработки вышележащему ПО.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Экзоядро        | Предоставляет лишь функции для взаимодействия между процессами, безопасного выделения и освобождения ресурсов.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |

#### 32. Поколения операционных систем. Классификация ОС. Интерфейсы операционных систем. Эволюция ОС. Эффективность ОС.

##### Поколения ОС:

- **Первое поколение (1945-1955):** На заре компьютерной эры каждым компьютером занималась своя команда инженеров. Все команды писались на машинном языке или даже строились электрическими схемами. Ничего даже близко похожего на ОС тогда не существовало. Да и не особо нужно было, ведь в основном компьютеры использовались для уточнения каких-то табличных значений (по типу синусов).
- **Второе поколение (1955-1965):** После применения транзисторов для построения компьютеров, появилось чёткое разделение между программистами и обслуживающим компьютер персоналом. Программист писал программу и переносил её на перфокарты, затем специальное устройство считывало программу и заносило всё на магнитную ленту. Эта лента вставлялась в компьютер и запускалась специальная программа (прообраз ОС). Она считывала задания с ленты и запускала его, записывая выходные данные на другую ленту. После работы вторая лента относилась на компьютер поменьше, который печатал информацию. После этого загружалась следующее задание.
- **Третье поколение (1965-1985):** К этому времени закрепились два типа компьютеров: большие и мощные (для научных работ и сложных вычислений) с пословной обработкой данных и небольшие, послабее (для повседневных задач или распечатки данных с больших компьютеров) с посимвольной обработкой. IBM хотела сделать такие типы совместимыми, чтобы одна программа могла работать на двух типах. Было разработано семейство машин IBM/360. У них была собственная ОС. Она обладала многозадачностью. Для этого память разбивалась на несколько разделов, в каждом из которых выполнялось своё задание. Также появилась возможность подкачки данных (spooling), когда раздел освобождался, ОС загружала новое задание с диска. Также в то время начала развиваться идея разделения времени, когда у каждого пользователя есть свой терминал для работы с машиной. Впоследствии была разработана система MULTCS а затем и UNIX.
- **Четвёртое поколение (1980-2025):** Происходило развитие микрокомпьютерных ОС. Компании IBM была нужна ОС для их нового IBM PC. Они обратились к Биллу Гейтсу, который выкупил у местного производителя компьютеров DOS (Disk Operating System) и с небольшими доработками отдал её IBM. Позже она была доработана до MS-DOS и быстро обрела доминирующее положение на рынке IBM PC. Далее начали появляться первые GUI. Изначально Windows был простой графической оболочкой, работающей поверх MS-DOS. Затем, в 1995 году, Windows отделилась как Windows 95 и впоследствии Windows 98. Это были системы, работающие на 16-разрядных процессорах. Позже вышла Windows NT для 32-разрядных систем. Параллельно ОС от Microsoft, развивались и другие системы. Для UNIX подобных систем была разработана X Window System, для графического интерфейса. Для этой системы можно было установить пользовательский интерфейс: Gnome/KDE. Также шло развитие сетевых, распределённых и мобильных ОС.

##### Классификация ОС:

- **ОС мейнфреймов**: отличаются огромными объёмами ввода/вывода данных. В основном ориентируются на одновременное выполнение огромного количества вычислений.
- **ОС серверов**: ориентируются на большое количество пользователей на одной машине.
- **Многопроцессорные ОС**: обеспечивают соединение множества центральных процессоров в единую систему для более эффективной работы.
- **ОС персональных компьютеров**: многозадачность.
- **ОС КПК.**
- **Встроенные ОС**.
- **ОС сенсорных узлов**: например системы видеонаблюдения.
- ОС реального времени: таким системам важно выполнить задачу в чётко заданное время. Бывают системы жёсткого и мягкого времени (строгие и не такие строгие). Например автопилот в самолёте или компьютер АЭС.

##### Интерфейсы взаимодействия ОС:

**Интерфейсы** — способы взаимодействия пользователя или приложений с ОС.

- **CLI (Command Line Interface)** — командная строка.
- **GUI (Graphical User Interface)** — графический интерфейс.
- **API (Application Programming Interface)** — набор функций для программного взаимодействия.
- **Системные вызовы (System Calls)** — низкоуровневый интерфейс программ к ядру ОС.

##### Эволюция ОС:

1) Переход от пакетной обработки к мультизадачности.
2) Появление многопользовательских систем.
3) Развитие GUI.
4) Расширение сетевых возможностей.
5) Развитие виртуализации и облачных технологий.
6) Развитие мобильных и встроенных ОС.

Эффективность ОС оценивается по **производительности**, **надёжности**, **устойчивости**, **безопасности**, **удобству использования**.

#### 33. Однопрограммные, многопрограммные, многопользовательские и многопроцессорные операционные системы и среды. Примеры распространенных ОС.

##### Однопрограммные ОС:

В каждый момент времени в памяти находится только одна программа, которая полностью задействует ресурсы процессора. Такой подход использовался в начале развития ОС. Пример: ранние версии MS-DOS.

##### Многопрограммные ОС:

В памяти находится сразу несколько программ и процессор может переключаться между ними. Такой подход эффективнее и используется сегодня во многих системах. Примеры: UNIX, Windows.

##### Многопользовательские ОС:

Несколько пользователей могут одновременно работать на одной машине. ОС будет распределять её ресурсы между ними. Примеры UNIX, Windows Server.

##### Многопроцессорные ОС:

Поддержка работы систем с несколькими процессорами для одновременного выполнения задач. Примеры Windows, Linux.

##### Среды:

**Среды ОС** — набор условий и инструментов, которые предоставляет операционная система для работы пользователя или программы. Среда это окружение, в котором загружается программа.

Различают два пространства (среды):

**Прикладная среда** (User space) — набор библиотек и сервисов для запуска приложений. Например Windows API или POSIX для UNIX систем.

**Системная среда** (Kernel) — переменные окружения, доступ к файловой системе и т.д.

![[Linux structure.png]]

##### Распространённые ОС:
- Windows
- Linux
- macOS
- Android
- iOS
- FreeBSD (многопользовательская)

#### 34. Прикладные операционные среды. Совместимость операционных систем. Виды совместимости. Языковая и двоичная совместимость.

В прикладных средах (User space) работают системы, которые не находятся в ядре по различным причинам.

##### Совместимость:
Можно придумать много разных примеров:
- **Файловая** — файлы с одной системы (NTFS от Windows) могут запускаться на другой (например на Linux). Это обеспечивается драйверами и виртуальными файловыми системами.
- **Прикладная** — возможность запускать приложения на разных системах. К примеру на Linux можно запускать приложения с Windows через WineHQ.
- **Стандарты POSIX (Portable Operating System Interface)** — чтобы системы были совместимыми (можно было переносить прикладные программы) был разработан стандарт POSIX. Он определял интерфейс ОС. Например он определяет набор стандартных системных утилит (cp, echo, cat…) для каждой совместимой системы.

**Языковая совместимость** — код нужно заново компилировать под каждую ОС.

**Двоичная совместимость** — совместимость на уровне готовых программных файлов. Код можно сразу запускать на другой системе.

#### 35. Эмуляция. Виртуальные машины и операционные среды.

**Эмуляция** — процесс, при котором одна система имитирует работу другой. Программа создаёт программную копию имитируемой аппаратной части. Например эмуляторы ARM-архитектуры. Wine имитирует Windows API для запуска приложений на Linux. Эмуляторы консолей на ПК.

**Виртуальная машина** — полная имитация одного компьютера внутри другого. Это работает с помощью технологии [виртуализации](Виртуализация.md).

**Операционные среды** — это окружение для приложений, которое эмулирует функции другой операционной системы без запуска отдельной ОС. Операционные среды просто реализуют API, не эмулируя работу железа какого-то устройства.

#### 36. Загрузка операционных систем (на примереe Windows, Linux). Этапы процесса загрузки. Работа загрузчика. Опции загрузочного меню. Выбор аппаратного профиля. Загрузка и инициализация ядра. Загрузка драйверов и сервисов. Регистрация пользователя.

##### Этапы загрузки Windows:
1) BIOS/UEFI выполняет POST (Power-On Self-Test), проверяя работоспособность устройств. Затем система идентифицирует допустимый системный диск и читает [^1]MBR (Master Boot Record) или GPT (GUID Partition Table) в зависимости от конфигурации. Это запускает Windows Boot Manager (WBM).
2) WBM может отображать меню загрузки, если на компьютере установлено несколько ОС. Пользователь может выбрать одну из них и например войти в безопасный режим.
3) Далее система использует технологию Plug-and-Play для автоматического обнаружения и конфигурации оборудования. Она сканирует слоты расширения (PCI), для идентификации подключенных устройств. В дальнейшем Windows будет загружать драйвера для этих устройств.
4) После запуска Boot Manager загружается Windows Loader, который загружает ядро (инициализирует). Оно инициализирует критические компоненты, такие как управление памятью и подготавливает систему к более высокоуровневым операциям.
5) После инициализации ядра Windows загружает драйверы устройств и системные службы (API, предоставляющий доступ прикладным программам, к аппаратным ресурсам системы).
6) Затем инициализируется GUI и отображает экран входа. Пользователь вводит имя пользователя и пароль, которые аутентифицируются через Security Accounts Manager (SAM). После успешной аутентификации загружается рабочий стол пользователя.

[^1]: MBR и GPT это разные схемы разделов для дисков. MBR это старая схема, ограничивающая диск до 2 ТБ и поддерживая 4 основных раздела. GPT – таблица разделов, работающая с глобально уникальными идентификаторами GUID (Globally Unique Identifier). Это современная схема, поддерживая огромные диски и до 128 разделов.

##### Этапы загрузки Linux:
1) BIOS/UEFI выполняет POST и загружает MBR с загрузочного диска. В этой записи содержится программа. которая запускает вторичный загрузчик, например GRUB (GRand Unified Bootloader) (их существует много), который читает конфигурационные файлы, чтобы узнать доступные ОС и т.п.
2) GRUB отображает различные варианты загрузки, позволяющие пользователю выбрать различные режимы восстановления и так далее.
3) Запускается начальный код ядра. Читаются конфигурационные файлы, для определения устройств ввода-вывода, и добавляются в таблицу устройств.
4) Далее GRUB загружает само ядро Linux и начальный RAM-диск (специальная файловая система для загрузки ОС) в память, передавая управление ядру. Его начальный код, написанный на ассемблере, определяет тип процессора, вычисляет доступную RAM, отключает прерывания, активирует MMU и вызывает процедуру, написанную на C, для продолжения запуска ядра.
5) После инициализации ядра система начинает конфигурацию оборудования. Загружаются драйверы. Ядро запускает процесс 0. который продолжает инициализацию, включая настройку таймеров, монтирование корневой файловой системы, и создания процесса 1 (init) и процесса-демона страниц (процесс 2). init, в зависимости от флагов, запускает систему в однопользовательском или многопользовательском режиме, запуская скрипты инициализации.
6) Далее init запускает программу getty, которая настраивает свойства терминала и отображает приглашение для ввода. Когда пользователь вводит имя, getty выполняет /bin/login, который запрашивает пароль и сравнивает его с информацией из /etc/passwd.

До этапа загрузки ядра процессор работает в реальном режиме (16 бит), затем переключается в защищенный (32 или 64 бит).

#### 37. Инсталляция и конфигурирование многопрограммной многопользовательской ОС с графическим интерфейсом (на примере Windows,). Требования к аппаратным ресурсам. Подготовка процесса инсталляции. Конфигурирование разделов на жестком диске. Выбор файловой системы. Выбор варианта установки (локальная, сетевая). Инсталляция мультиоперационных систем.

##### Локальная установка Windows:

1) Проверить устройство на соответствие минимальным требованиям: процессор 1ГГц, 2 Гб (64-разрядная версия) или 1 Гб (32-разрядная) ОЗУ, 32 Гб дискового пространства.
2) Для установки необходимо создать загрузочный носитель. Оптимальным вариантом является флешка. Она должна быть не менее 8 Гб. Для создания такого носителя необходимо установить специальную программу Media Creation Tool и следовать инструкциям в ней.
3) В BIOS/UEFI нужно выбрать в качестве boot device это загрузочное устройство, и тогда ОС начнёт загружаться.

##### Сетевая установка Windows:

1) Необходимо настроить WDS на сервере. Он нужен чтобы клиенты обращались к нему и получали загрузочные образы.
2) Далее нужно настроить PXE, чтобы машина могла загружаться по сети. Компьютер запрашивает загрузочный образ у сервера, получает и начинает установку Windows.
Такой способ удобен для массовой установки в корпоративных средах.

##### Конфигурирование разделов:

Во время установки можно создать разделы на жёстком диске. Для этого нужно выбрать пользовательский режим установки и создать новый раздел. Также это возможно сделать через консоль. Для этого нужно открыть её (Shift + F10) и ввести команду `diskpart`. Далее можно посмотреть список дисков (`list disk`), выбрать нужный (`select disk <номер_диска>`) и создать раздел (`create partition primary size=n`).

##### Выбор файловой системы:

Windows 10 по умолчанию использует файловую систему NTFS, которая является хорошим выбором. Также Windows поддерживает FAT, но это немного устаревший формат, поэтому не рекомендуется форматировать диски под него.

##### Инсталляция мультиоперационных систем:

Для установки нескольких ОС (например двух) необходимо предварительно создать разделы диска под каждую ОС. Затем необходимо по очереди установить ОС. Если первая ОС не отображается, нужно использовать инструменты для восстановления загрузчика (Boot-Repair в Linux).

#### 38 - 39. Концепция процессов и потоков. Определение и модель процесса. Создание и завершение процессов. Иерархия процессов. Операции над процессами. Состояния процесса: выполнение, приостановка, возобновление. Блок управления процессами. Алгоритмы планирования.

**Процесс** — это экземпляр исполняемой программы (абстракция исполняемой программы), включающий текущие значения счетчика команд, регистров и переменных. Процесс состоит из нескольких частей: текстовый сегмент, в котором содержится исполняемый код программы, сегмент данных, в котором хранятся данные, необходимые для работы программы и сегмент стека (контекст), в котором хранится контекст вызова, например, переменные окружения и команду, с помощью которой была запущена программа (так она сможет понять, с какими аргументами её запустили).


Виртуальное адресное пространство процесса делится на User Space и Kernel Space. Первое используется, когда процесс работает в пользовательском режиме, а второй — в режиме ядра. В них хранятся данные для работы каждого режима.

Текстовый сегмент находится в самой нижней части пространства. За ним располагаются два сегмента данных: первый для инициализированных переменных, второй для неинициализированных. Ещё выше находится куча (Heap). Она используется для динамически выделяемых данных (размер или срок жизни которых нельзя предсказать на этапе компиляции (массивы, списки, хэш-таблицы)). В самом верху пространства пользователя находится стек, который хранит информацию о вызовах функций и системных вызовах.
![[Process scheme.png]]

**Потоки** — аналоги процессов, которые делят память внутри одного процесса. (дальше есть более подробная информация про них)

##### Состояния процесса:

У процесса может быть 3 основных состояния:
- **Выполнение** — процесс использует CPU.
- **Готовность** — процесс ждёт пока его выберет планировщик.
- **Блокировка** — процесс ожидает какого-то события, например, завершения операции ввода/вывода.

Также существует семиступенчатая модель:
- **Новый** — процесс только что создан.
- **Готов** — загружен в основную память, ждет свободного CPU.
- **Выполняется** — процесс использует CPU.
- **Заблокированный/ожидающий** — ожидает I/O, пользовательского ввода или критической секции.
- **Terminated/Completed** — убит или выполнен, ресурсы освобождены.
- **Приостановленный готовый** — готовый процесс, который выгружен на внешнее хранилище.
- **Приостановленный заблокированный** — заблокированный процесс, который выгружен на внешнее хранилище.

##### Создание процесса и завершение процесса


Создание процесса может произойти через:
- Инициализацию самой ОС (например init при старте системы).
- Создание процесса как дочернего от какого-то другого (fork).
- Создание процесса по запросу пользователя (например какая-нибудь команда в bash).
- Инициализацию пакетного задания. Это происходит в мейнфреймах и вычислительных центрах, где пользователи подготавливают задания, которые загружаются в файл и помещаются в очередь. ОС запускает процессы из этой очереди, таким образом инициатором создания является система, но по предварительной заявке пользователя.

Варианты завершения процесса:
- Нормальное завершение (добровольно) — вызов команды exit(0) (0 - код штатного завершения), процесс добровольно выходит, выгружая свои ресурсы.
- Выход при возникновении ошибки (добровольно) — процесс завешается с кодом ошибки.
- Возникновение критической ошибки (принудительно) — ОС принудительно завешает процесс из-за критической ошибки, например, сегфолта или деления на ноль.
- Завершение из другого процесса (принудительно) — внешний процесс завершает данный с помощью сигнала SIGKILL.

##### Системные вызовы для управления процессами:
- `pid=fork()` — создать дочерний процесс, идентичный родительскому.
- `pid=waitpid(pid, &statloc, opts)` — ждать завершения дочернего процесса.
- `s=execve(name, argv, envp)` — заменить образ памяти процесса.
- `exit(status)` — завершить выполнение процесса и вернуть статус.
- `s=sigaction(sig, &act, &oldact)` — определить действие, выполняемое при приходе сигнала.
- `s=kill(pid, sig)` — послать сигнал процессу.

fork() — системный вызов, который создаёт точную копию родительского процесса, включая адресное пространство. fork() возвращает значение, равное нулю, если выполняется в дочернем процессе и PID дочернего процесса, если в родительском.

После fork(), у родительского процесса обычно вызывается waitpid, который ждёт завершения дочернего процесса (если указать PID, то будет ждать определённого, если -1, то любого). Для дочернего процесса вызывается `execve`, который заменяет образ памяти (который наследовался от родителя) на программу, которую должен выполнять дочерний процесс.

Упрощенный пример оболочки:
```
while (TRUE) {
    /* бесконечный цикл */

    type_prompt();                   /* вывести приглашение к вводу */
    read_command(command, params);  /* прочитать с клавиатуры строку ввода */

    pid = fork();                   /* ответвить дочерний процесс */

    if (pid < 0) {
        printf("Создать процесс невозможно");  /* ошибка */
        continue;                              /* повторить цикл */
    }

    if (pid != 0) {
        waitpid(-1, &status, 0);   /* родительский процесс ждет дочерний процесс */
    } else {
        execve(command, params, 0);  /* дочерний процесс выполняет работу */
    }
}
```

##### Иерархия процессов:

Все процессы происходят от корневого процесса init. Они инициализируются путём вызова fork. Также могут быть осиротевшие процессы (если родительский процесс завершился), они становятся детьми init.

##### Блок управления процессами:

Процессы хранятся в таблице процессов. Каждая запись в ней называется PCB. Таблица страниц не может быть выгружена.

**PCB (Process Control Block)** — это структура данных (дескриптор процесса), которую операционная система использует для хранения информации о процессе.

PCB содержит данные и указатели на области:
- PID.
- Текущее состояние процесса (например, Ready, Running, Blocked).
- Счетчик команд (Program Counter), который указывает на следующую инструкцию для выполнения.
- Регистры процессора.
- Указатели на сегменты текста, данных и стека.
- Список открытых файлов и дескрипторов.
- Статус ввода-вывода.

##### Алгоритмы планирования
Алгоритмы [здесь](Планирование)

#### 40. Обработка прерываний.

**Прерывание** — это сигнал, который прерывает нормальный поток выполнения процессора, требуя немедленной обработки.

##### Классификация прерываний:

- **Внешние** (аппаратные) — возникают от внешних устройств: таймеры, устройства ввода/вывода. Называются асинхронными, ведь процессор не знает в какой момент они произойдут.
- **Внутренние** — вызываются самим процессором, например, при делении на ноль, обращении к недоступному адресу или переполнении стека. Называются синхронными так как они предсказуемо связаны с потоком выполнения программы. Если повторно выполнить программу, прерывание произойдёт в том же месте.
- **Программные** — инициализируются инструкциями. Например INT (ассемблер) (от interrupt) в x86 архитектуре процессоров. Команда буквально инициирует переход к обработчику прерываний с заданным номером. Номер обозначает к какому обработчику идёт обращение. 
- **Маскируемые** — некоторые прерывания могут быть отключены программно. Процессор будет их просто игнорировать.
- **Немаскируемые** — прерывания, которые нельзя отключить.


##### Механизм обработки прерываний:

1) **Обнаружение**. Процессор мониторит линии прерываний, чтобы обнаружить сигнал.
2) **Подтверждение**. При получении сигнала, процессор оповещает устройство, которое его вызвало, о начале обработки, чтобы оно прекратило посылать сигнал.
3) **Сохранение контекста**. Прерывание — это переключение контекста процессора, поэтому необходимо сохранить его текущее состояние, чтобы позже к нему вернуться.
4) **Переход к обработчику**. Находится нужный обработчик и осуществляется переход к нему.
5) **Выполнение**. Обработчик выполняет необходимые действия.
6) **Восстановление**. Восстанавливается сохранённое состояние процессора и возобновляется выполнение.

#### 41. Ядро операционной системы.

**Ядро операционной системы** — это центральный компонент, который управляет ресурсами компьютера и обеспечивает взаимодействие между аппаратным и программным обеспечением. Оно действует как низший уровень абстракции, позволяя приложениям получать доступ к необходимым ресурсам через межпроцессное взаимодействие и системные вызовы.

##### Основные функции ядра:

###### Управление процессами:

Ядро отвечает за создание, планирование и завершение процессов. Также ядро может управлять и потоками (если они реализованы на уровне ядра).

###### Управление памятью:

Ядро выделяет и освобождает память для процессов, управляет виртуальной памятью и обеспечивает изоляцию адресных пространств процессов.

###### Управление устройствами:

Через [драйверы](Драйверы)  ядро взаимодействует с аппаратными компонентами ввода/вывода, такими как клавиатуры, мониторы, сетевые карты и т.д.

###### Управление файловой системой:

Ядро предоставляет интерфейс для взаимодействия с файлами и каталогами, обеспечивая доступ к данным на различных носителях (HDD/SSD). Оно выполняет операции чтения, записи, удаления файлов.

###### Управление сетью:

Ядро реализует сетевые протоколы и обрабатывает пакеты.

###### Системные вызовы и безопасность:

Организация обращений к ядру через системные вызовы обеспечивает безопасность, предотвращая несанкционированный доступ к ресурсам и защищая само ядро от вмешательства приложений. Системные вызовы производятся при помощи прерываний.

#### 42. Потоки и их использование. Модель потока. Реализация потоков в пространстве пользователя. Реализация потоков в ядре. Смешанная реализация. Активация планировщика.

**Потоки** — это последовательные потоки выполнения задач внутри процесса, которые позволяют разделить процесс на независимые задачи. Они делят с процессом код, данные и ресурсы операционной системы, такие как открытые файлы, но имеют собственный стек, счетчик программы и набор регистров. Из-за общих данных поток создаётся гораздо быстрее чем процесс (не надо выделять память или создавать объёмные PCB).

##### Реализация потоков на уровне пользователя:

Потоки в пространстве пользователя (User-Level Threads, ULT) управляются библиотекой в пространстве пользователя, без вмешательства ядра.

**Преимущества:**
- Из-за того, что ядро не вмешивается (не происходит постоянного переключения контекстов), создание, уничтожение и переключение между потоками происходит очень быстро.
- Такие потоки могут работать в ОС, в которой потоки не поддерживаются. Также из этого следует, что программист может сам написать логику планирования потоков.

**Недостатки:**
- Если один поток вызывает блокирующий вызов, блокируется весь процесс.
- Так как ядро видит только один поток (ULT как бы находятся внутри KLT, а при такой реализации KLT один), ОС не может планировать их работу по отдельности и распределять по разным процессорам.

##### Реализация потоков на уровне ядра:

Потоки в ядре (Kernel-Level Threads, KLT) управляются операционной системой и являются частью ядра.

**Преимущества:**
- Потоки могут выполнятся параллельно, на разных процессорах.
- Если один поток делает блокирующий системный вызов, то остальные потоки продолжают работать.

**Недостатки:**
- Большие накладные расходы (переключение контекста), соответственно операции над ними производятся медленнее.
- Ядро может ограничивать допустимое количество потоков.

##### Смешанная реализация:

Смешанная реализация (Many-to-Many Model) сочетает пользовательские и ядерные потоки, обеспечивая гибкость и производительность. Библиотека в пространстве пользователя управляет пользовательскими потоками, а ядро управляет потоками ядра, обеспечивая координацию между уровнями.

Сочетает преимущества двух реализаций, но требуют сложной координации между пользовательским и ядерным уровнем.

##### Модель потока:

Модель определяет, как потоки взаимодействуют с процессом и ОС. В любой модели KLT содержит в себе ULT (например как процессы содержат потоки). Это означает что ОС может взаимодействовать только с наружной частью (KLT).

- **Многие-к-одному** — управление потоками осуществляется библиотекой в пространстве пользователя, что делает создание и переключение потоков быстрым (из-за отсутствия переключения контекста), но если один поток выполнит блокирующий вызов, заблокируется весь процесс. Т.е. это реализация потоков на уровне пользователя.
- **Один-к-одному** — каждый пользовательский поток имеет поток ядра. Можно сказать что это просто реализация потоков на уровне ядра.
- **Многие-ко-многим** — гибридная модель, где многие пользовательские потоки отображаются на равное или меньшее количество потоков ядра. Это означает, что каждый поток ядра как бы содержит несколько потоков пользователя. Если один из пользовательских потоков выполняет блокирующий вызов, блокируется только поток уровня ядра, в котором он хранится (правильнее "которому соответствует"). Т.е. это смешанная реализация.

##### Активация планировщика:

**Scheduler Activations** — это механизм, при котором ядро и пользовательская библиотека потоков сотрудничают, чтобы обеспечить быстроту ULT и параллельность KLT.

При таком подходе применяются легковесные процессы (Lightweight Processes, LWP) (LWP это абстракция, выполняющая работу). В современных ОС можно сказать KLT = LWP. Предположим что у нас есть 20 ULT и 4 процессора, между которыми их нужно распределить.
Выделяется 4 LWP с помощью scheduler activations. LWP будет сообщать библиотеке потоков уровня пользователя о различных событиях. Предположим что на процессоре №2 ULP#4 заблокировался. Вместо того, чтобы блокировать весь LWP (который содержит и другие ULP), посылается upcall — сообщение библиотеке о том, что один из её потоков заблокировался и что нужно выбрать новый. Библиотека должна решить какой поток ставить вместо заблокированного. Таким образом остаются положительные стороны двух реализаций потоков, но для этого нужно реализовать крайне сложную систему как со стороны ядра ОС, так и со стороны библиотеки

#### 43. Всплывающие потоки (нити). Возможности создания многопоточных программ. Концепция волокон.

**Всплывающий поток (pop-up thread)** — это поток, который автоматически создаётся системой при поступлении входящего сообщения (например, сетевого запроса), исключительно для обработки этого сообщения.

Основное преимущество данных потоков заключается в быстроте. Они создаются с чистого листа, без необходимости восстанавливать регистры, стек и другие данные. Из-за этого их используют в распределённых системах и серверах.  (они минимизируют задержку между поступлением сообщения и началом его обработки, обеспечивая быстрый отклик).

##### Возможности создания многопоточных программ:

Создание многопоточных программ возможно из-за широкого набора инструментов, предоставляемых различными языками программирования и операционными системами. Они позволяют создавать мьютексы, семафоры и другие структуры для управления общим доступом к ресурсам.

##### Концепция волокон:

**Волокна (fibers)** — это легковесные потоки, управляемые приложением, а не операционной системой. Это ULT.

#### 44. Взаимодействие и синхронизация процессов и потоков. Параллельные асинхронные процессы и межпроцессное взаимодействие. Уровни параллелизма: задания, задачи, процессы, потоки Состояния состязания.

**Процессы** во время своего выполнения могут взаимодействовать между собой через механизмы межпроцессорного взаимодействия (IPC).
**Потоки** также взаимодействуют между собой, только гораздо проще, ведь у них общее адресное пространство.

Но тут может возникнуть проблема синхронизации. Когда несколько процессов или потоков допускаются к общим ресурсам (например, разделяемой памяти), может возникнуть состояние состязания (race condition), если порядок доступа не контролируется.

**Состояния состязания (Race Conditions)** — состояние, когда два или более процесса или потока допускаются к общему ресурсу (например, разделяемой памяти) одновременно, и результат зависит от порядка их выполнения. Оно может привести к неопределённому поведению в программе.

**Параллельные процессы** — процессы, которые выполняются одновременно, что достигается за счет распределения задач по нескольким процессорам или ядрам.

**Асинхронные процессы** — процессы, которые не ждут завершения друг друга, а продолжают выполнение независимо. Они часто используется для задач с вводом-выводом или с удалёнными запросами.

**Межпроцессное взаимодействие (IPC)** — это обмен данными между процессами, которые могут работать на одном компьютере или в сети.

**Основные механизмы:**
- *Сокеты* — запись и чтение общего файла или сетевого соединения.
- *Каналы (pipe)* — односторонний поток между процессами.
- *Очереди сообщений* — процесс может поместить в очередь сообщение, а другой может его оттуда прочитать посредством системных вызовов, при условии того, что процессы используют одинаковый ключ доступа.
- *Разделяемая память* — область, общая для нескольких процессов.

##### Уровни параллелизма:

**Задания (Jobs)** — наивысший уровень параллелизма. Это крупная единица работы, которая может быть разделена на задачи. Например, в пакетных системах задание может включать несколько программ, выполняемых последовательно или параллельно

**Задачи (Tasks)** — часть задания, которая может быть выполнена независимо. Они распределяются по процессам и потокам.

**Процессы (Processes)** — независимые единицы выполнения с собственным адресным пространством. Они выполняются на разных процессорах, таким образом достигается параллельная работа.

**Потоки (Threads)** — легковесные процессы, делящие адресное пространство в пределах одного процесса между собой. Потоки также могут выполняться на нескольких процессах.

#### 45. Взаимоисключения и критические участки. Примитивы и алгоритмы взаимоисключения.

**Взаимоисключение (mutual exclusion)** — это концепция, которая обеспечивает, что только один процесс или поток может получить доступ к общему ресурсу в один момент времени. Это необходимо для предотвращения состояний состязания (race conditions).

**Критические участки (critical sections)** — это части программного кода, где происходит доступ к общим ресурсам. Одновременный доступ к этим ресурсам без контроля может привести к состоянию состязания, где результат зависит от порядка выполнения операций. Например, если два процесса пытаются увеличить общий счетчик, один может перезаписать изменения другого, что приведет к потере данных.

Для предотвращения таких ситуаций необходимо обеспечить, чтобы только один процесс или поток мог находиться в критической секции в один момент времени. Это достигается с помощью механизмов взаимоисключения, которые гарантируют, что доступ к ресурсам строго упорядочен.

**Примитивы** — это базовые инструменты, используемые для реализации взаимоисключения. Они предоставляют низкоуровневые механизмы для управления доступом к критическим секциям. К ним относятся Семафоры, мьютексы, мониторы и аппаратные примитивы (Test-and-Set).

**Алгоритмы** — это методы, которые используют примитивы или другие техники для обеспечения того, чтобы только один процесс или поток мог войти в критическую секцию в один момент времени.

**Атомарные инструкции (atomic instructions)** — операции, которые выполняются полностью или не выполняются вовсе, без прерываний другими потоками. Если они начали своё выполнение, то они не могут быть прерваны.

- **Алгоритм Петерсона** — обеспечивает программное решение проблемы для *двух процессов*. Алгоритм использует две общие переменные, где каждый процесс устанавливает свой флаг, когда хочет зайти в критическую область, и переменную turn, которая указывает, чья очередь входить. У такого алгоритма есть недостатки: он работает только для двух конкурирующих потоков (процессов) и в нём присутствует активное ожидание (пустой цикл, который просто так нагружает процессор). Современные процессоры могут изменять последовательность доступа к памяти по своему усмотрению (для более эффективной работы), а для корректной работы алгоритма крайне важен порядок выполнения инструкций, поэтому такой подход сегодня и не используется (библиотека `atomic` из примера как раз исправляет эту проблему).
```
#include <atomic>

std::atomic<bool> flag[2];
std::atomic<int> turn; // доступ должен быть атомарным

void enter_critical(int id) {
    int other = 1 - id;
    flag[id] = true;
    turn = other;
    while (flag[other] && turn == other); // ожидание
}

void exit_critical(int id) {
    flag[id] = false;
}
```

- **Алгоритмы на основе токенов (Token-based Algorithms)** — только процесс, владеющий токеном, может войти в критическую секцию. Принцип, похожий на [[Token Ring]].
- **Алгоритмы на основе кворумов (Quorum-based Algorithms)** — процесс должен получить разрешение от большинства (кворума) других процессов, чтобы войти в критическую секцию.

#### 46. Семафоры, мониторы, передача сообщений. Проблемы межпроцессного взаимодействия.

**Спин блокировки (spinlock)** — механизм, который постоянно проверяет, свободна ли блокировка, не покидая CPU. Spinlock это механизм, который служит основой для более сложных структур (для [семафоров](Семафоры), [мьютексов](Мьютексы), [мониторов](мониторы)).

```
struct spinlock_t {
    int acquired = 0; // какой-то объект, у которого есть атрибут acquired (занят)
};

// Это демонстрационная реализация аппаратной атомарной функции
// она должна выполняться как одна неделимая инструкция
int TestAndSet(int* val) {
    int oldValue = *val;
    *val = 1;
    return oldValue;
}

void Lock(spinlock_t* s) {
    while (TestAndSet(&s->acquired)); // активное ожидание
}

void Unlock(spinlock_t* s) {
    s->acquired = 0;
}
```

#### 47. Ресурсы и их захват процессами. Выгружаемые и невыгружаемые ресурсы. Примеры тупиков при распределении ресурсов. Обнаружение и предотвращение тупиков. Алгоритмы разрешения тупиков. Восстановление после тупиков.

#### 48. Моделирование на языках высокого уровня вычислительного процесса многопрограммных операционных систем с детализацией уровней задач, процессов, потоков и тупиков.

#### 49. Мультипрограммирование. Аппаратно-программные средства поддержки мультипрограммирования.

#### 50. Иерархическая организация памяти. Функции ОС по управлению памятью. Задачи распределения памяти. Алгоритмы распределения памяти. Распределение фиксированными и динамическими разделами.