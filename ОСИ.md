#### 28. Определение операционной системы (ОС). Место ОС в программном обеспечении компьютеров, компьютерных систем и сетей. Тенденции и перспективы развития операционных систем и сред.

**Операционная система** — это набор программ, который управляет аппаратными средствами компьютера и предоставляет среду для выполнения программ. ОС служит мостом между пользователем и компьютером, обеспечивая ресурсы для программ, управление файлами, памятью, процессами и многозадачностью.

##### Место ОС

В обеспечении компьютеров ОС играет важную роль, ведь она предоставляет интерфейс для взаимодействия пользователя, обеспечивает эффективное взаимодействие аппаратных частей компьютера и многое другое.

В компьютерных системах ОС обеспечивает эффективное взаимодействие узлов системы и централизованное управление.

ОС также часто используются в компьютерных сетях. Примером могут послужить ОС маршрутизаторов, коммутаторов и других сетевых устройств. Или например веб-хостинги. На их серверах стоят ОС, которые позволяют эффективно отвечать на запросы клиентов. В конце концов ОС обычных компьютеров участвует в сетевом соединении, обрабатывает пакеты, управляет сетевыми интерфейсами и многое другое.

##### Тенденции и перспективы

Направлений для развития ОС можно увидеть бесконечное множество. В последние годы сильно развиваются ОС мобильных устройств и встраиваемых устройств (устройства умного дома). Перспективным является направление разработки ОС, у которых в приоритете находится безопасность. ОС для квантовых компьютеров. Интеграция ИИ в ОС.

#### 29. Назначение, состав и функции ОС. Понятие компьютерных ресурсов.

##### Основные назначения ОС:
- Управление аппаратными компонентами и из взаимодействием. Распределение этих ресурсов между пользователями и процессами.
- Абстракция. Предоставление удобного интерфейса для взаимодействия с компьютером для пользователя. Сюда же можно отнести предоставление удобных функций для разработчиков ПО.
- Обеспечение безопасности и сохранности данных.
- Обеспечение связи между компьютерами в сети.
- Планирование задач, многозадачность...

##### Состав ОС: (по Васильеву)
- Текстовый пользовательский интерфейс
- GUI
- Программные библиотеки
- Утилиты
- Пользовательские программы

##### Функции ОС:
- Выполнение программ.
- Управление файловой системой.
- Управление устройствами ввода/вывода.

##### Понятие компьютерных ресурсов

**Ресурсы** — средства, имеющиеся в наличии, но к которым обращаются лишь при необходимости.

Существует много видов компьютерных ресурсов: аппаратные, файловые, программные (совокупность установленных программ), ресурс памяти (как постоянной, так и виртуальной) и многие другие.

Например к аппаратным ресурсам относятся: CPU, RAM, HDD/SSD, сетевые интерфейсы, устройства ввода/вывода.

#### 30. Концепция многоуровневого виртуального компьютера. Операционные оболочки и среды.

**Многоуровневый виртуальный компьютер** — это система, где физический компьютер может запускать несколько виртуальных машин, а внутри каждой из них можно создать еще одну виртуальную машину. Это создает многоуровневую структуру, где каждый уровень работает независимо, как отдельный компьютер. Используются в областях тестирования, кибербезопасности.

**Операционная оболочка** — это программа, предоставляющая интерфейс для взаимодействия пользователя с функциями операционной системы. Это может быть как командная строка, так и графический интерфейс.

#### 31. Архитектуры операционных систем.

| Тип архитектуры | Краткое описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Монолитное ядро | Все основные функции ОС встроены прямо в ядро. Обладает высокой скоростью, но слабой отказоустойчивостью. Представителями являются большинство UNIX-систем. При обращении к ядру происходит смена контекста (user mode -> kernel mode), выполнение запроса и возвращение обратно к программе (kernel -> user).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Микроядро       | Ядро содержит только самые базовые функции (прерывания, процессы, планирование, межпроцессорное взаимодействие (IPC — Inter Process Communications), память). Остальное вынесено в отдельные процессы в пространстве пользователя. Такая система медленнее из-за постоянных переключений контекста (world switch). Но в то же время она надёжнее. Также такую систему проще расширять. Самыми яркими представителями являются MINIX и Mach (ядро Mac OS X). При обращении к ядру, происходит смена контекста (user -> kernel), микроядро переходит выполняет переход к службе, находящейся в пространстве пользователя (kernel -> user), запрос выполняется и управление снова передаётся микроядру (user -> kernel) и наконец происходит возвращение к вызвавшему процессу (kernel -> user). |
| Гибридное ядро  | Модифицированные микроядра, которые позволяют запускать "несущественные" части в пространстве пользователя. Представителями являются NT Kernel, BSD-основанные.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Модульное ядро  | Модульные ядра, в отличие от «классических» монолитных ядер, не требуют полной перекомпиляции ядра, если меняется оборудование компьютера. Вместо этого, они позволяют загружать нужные модули (например, драйвера) для работы с новым аппаратным обеспечением без необходимости переписывать всё ядро.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Наноядро        | Крайне упрощенное и минималистичное ядро выполняет лишь обработку аппаратных прерываний. После этого оно посылает информацию о результатах обработки вышележащему ПО.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Экзоядро        | Предоставляет лишь функции для взаимодействия между процессами, безопасного выделения и освобождения ресурсов.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |

#### 32. Поколения операционных систем. Классификация ОС. Интерфейсы операционных систем. Эволюция ОС. Эффективность ОС.

##### Поколения ОС:

- **Первое поколение (1945-1955):** На заре компьютерной эры каждым компьютером занималась своя команда инженеров. Все команды писались на машинном языке или даже строились электрическими схемами. Ничего даже близко похожего на ОС тогда не существовало. Да и не особо нужно было, ведь в основном компьютеры использовались для уточнения каких-то табличных значений (по типу синусов).
- **Второе поколение (1955-1965):** После применения транзисторов для построения компьютеров, появилось чёткое разделение между программистами и обслуживающим компьютер персоналом. Программист писал программу и переносил её на перфокарты, затем специальное устройство считывало программу и заносило всё на магнитную ленту. Эта лента вставлялась в компьютер и запускалась специальная программа (прообраз ОС). Она считывала задания с ленты и запускала его, записывая выходные данные на другую ленту. После работы вторая лента относилась на компьютер поменьше, который печатал информацию. После этого загружалась следующее задание.
- **Третье поколение (1965-1985):** К этому времени закрепились два типа компьютеров: большие и мощные (для научных работ и сложных вычислений) с пословной обработкой данных и небольшие, послабее (для повседневных задач или распечатки данных с больших компьютеров) с посимвольной обработкой. IBM хотела сделать такие типы совместимыми, чтобы одна программа могла работать на двух типах. Было разработано семейство машин IBM/360. У них была собственная ОС. Она обладала многозадачностью. Для этого память разбивалась на несколько разделов, в каждом из которых выполнялось своё задание. Также появилась возможность подкачки данных (spooling), когда раздел освобождался, ОС загружала новое задание с диска. Также в то время начала развиваться идея разделения времени, когда у каждого пользователя есть свой терминал для работы с машиной. Впоследствии была разработана система MULTCS а затем и UNIX.
- **Четвёртое поколение (1980-2025):** Происходило развитие микрокомпьютерных ОС. Компании IBM была нужна ОС для их нового IBM PC. Они обратились к Биллу Гейтсу, который выкупил у местного производителя компьютеров DOS (Disk Operating System) и с небольшими доработками отдал её IBM. Позже она была доработана до MS-DOS и быстро обрела доминирующее положение на рынке IBM PC. Далее начали появляться первые GUI. Изначально Windows был простой графической оболочкой, работающей поверх MS-DOS. Затем, в 1995 году, Windows отделилась как Windows 95 и впоследствии Windows 98. Это были системы, работающие на 16-разрядных процессорах. Позже вышла Windows NT для 32-разрядных систем. Параллельно ОС от Microsoft, развивались и другие системы. Для UNIX подобных систем была разработана X Window System, для графического интерфейса. Для этой системы можно было установить пользовательский интерфейс: Gnome/KDE. Также шло развитие сетевых, распределённых и мобильных ОС.

##### Классификация ОС:

- **ОС мейнфреймов**: отличаются огромными объёмами ввода/вывода данных. В основном ориентируются на одновременное выполнение огромного количества вычислений.
- **ОС серверов**: ориентируются на большое количество пользователей на одной машине.
- **Многопроцессорные ОС**: обеспечивают соединение множества центральных процессоров в единую систему для более эффективной работы.
- **ОС персональных компьютеров**: многозадачность.
- **ОС КПК.**
- **Встроенные ОС**.
- **ОС сенсорных узлов**: например системы видеонаблюдения.
- ОС реального времени: таким системам важно выполнить задачу в чётко заданное время. Бывают системы жёсткого и мягкого времени (строгие и не такие строгие). Например автопилот в самолёте или компьютер АЭС.

##### Интерфейсы взаимодействия ОС:

**Интерфейсы** — способы взаимодействия пользователя или приложений с ОС.

- **CLI (Command Line Interface)** — командная строка.
- **GUI (Graphical User Interface)** — графический интерфейс.
- **API (Application Programming Interface)** — набор функций для программного взаимодействия.
- **Системные вызовы (System Calls)** — низкоуровневый интерфейс программ к ядру ОС.

##### Эволюция ОС:

1) Переход от пакетной обработки к мультизадачности.
2) Появление многопользовательских систем.
3) Развитие GUI.
4) Расширение сетевых возможностей.
5) Развитие виртуализации и облачных технологий.
6) Развитие мобильных и встроенных ОС.

Эффективность ОС оценивается по **производительности**, **надёжности**, **устойчивости**, **безопасности**, **удобству использования**.

#### 33. Однопрограммные, многопрограммные, многопользовательские и многопроцессорные операционные системы и среды. Примеры распространенных ОС.

##### Однопрограммные ОС:

В каждый момент времени в памяти находится только одна программа, которая полностью задействует ресурсы процессора. Такой подход использовался в начале развития ОС. Пример: ранние версии MS-DOS.

##### Многопрограммные ОС:

В памяти находится сразу несколько программ и процессор может переключаться между ними. Такой подход эффективнее и используется сегодня во многих системах. Примеры: UNIX, Windows.

##### Многопользовательские ОС:

Несколько пользователей могут одновременно работать на одной машине. ОС будет распределять её ресурсы между ними. Примеры UNIX, Windows Server.

##### Многопроцессорные ОС:

Поддержка работы систем с несколькими процессорами для одновременного выполнения задач. Примеры Windows, Linux.

##### Среды:

**Среды ОС** — набор условий и инструментов, которые предоставляет операционная система для работы пользователя или программы. Среда это окружение, в котором загружается программа.

Различают два пространства (среды):

**Прикладная среда** (User space) — набор библиотек и сервисов для запуска приложений. Например Windows API или POSIX для UNIX систем.

**Системная среда** (Kernel) — переменные окружения, доступ к файловой системе и т.д.

![[Linux structure.png]]

##### Распространённые ОС:
- Windows
- Linux
- macOS
- Android
- iOS
- FreeBSD (многопользовательская)

#### 34. Прикладные операционные среды. Совместимость операционных систем. Виды совместимости. Языковая и двоичная совместимость.

В прикладных средах (User space) работают системы, которые не находятся в ядре по различным причинам.

##### Совместимость:
Можно придумать много разных примеров:
- **Файловая** — файлы с одной системы (NTFS от Windows) могут запускаться на другой (например на Linux). Это обеспечивается драйверами и виртуальными файловыми системами.
- **Прикладная** — возможность запускать приложения на разных системах. К примеру на Linux можно запускать приложения с Windows через WineHQ.
- **Стандарты POSIX (Portable Operating System Interface)** — чтобы системы были совместимыми (можно было переносить прикладные программы) был разработан стандарт POSIX. Он определял интерфейс ОС. Например он определяет набор стандартных системных утилит (cp, echo, cat…) для каждой совместимой системы.

**Языковая совместимость** — код нужно заново компилировать под каждую ОС.

**Двоичная совместимость** — совместимость на уровне готовых программных файлов. Код можно сразу запускать на другой системе.

#### 35. Эмуляция. Виртуальные машины и операционные среды.

**Эмуляция** — процесс, при котором одна система имитирует работу другой. Программа создаёт программную копию имитируемой аппаратной части. Например эмуляторы ARM-архитектуры. Wine имитирует Windows API для запуска приложений на Linux. Эмуляторы консолей на ПК.

**Виртуальная машина** — полная имитация одного компьютера внутри другого. Это работает с помощью технологии [виртуализации](Виртуализация.md).

**Операционные среды** — это окружение для приложений, которое эмулирует функции другой операционной системы без запуска отдельной ОС. Операционные среды просто реализуют API, не эмулируя работу железа какого-то устройства.

#### 36. Загрузка операционных систем (на примереe Windows, Linux). Этапы процесса загрузки. Работа загрузчика. Опции загрузочного меню. Выбор аппаратного профиля. Загрузка и инициализация ядра. Загрузка драйверов и сервисов. Регистрация пользователя.

##### Этапы загрузки Windows:
1) BIOS/UEFI выполняет POST (Power-On Self-Test), проверяя работоспособность устройств. Затем система идентифицирует допустимый системный диск и читает [^1]MBR (Master Boot Record) или GPT (GUID Partition Table) в зависимости от конфигурации. Это запускает Windows Boot Manager (WBM).
2) WBM может отображать меню загрузки, если на компьютере установлено несколько ОС. Пользователь может выбрать одну из них и например войти в безопасный режим.
3) Далее система использует технологию Plug-and-Play для автоматического обнаружения и конфигурации оборудования. Она сканирует слоты расширения (PCI), для идентификации подключенных устройств. В дальнейшем Windows будет загружать драйвера для этих устройств.
4) После запуска Boot Manager загружается Windows Loader, который загружает ядро (инициализирует). Оно инициализирует критические компоненты, такие как управление памятью и подготавливает систему к более высокоуровневым операциям.
5) После инициализации ядра Windows загружает драйверы устройств и системные службы (API, предоставляющий доступ прикладным программам, к аппаратным ресурсам системы).
6) Затем инициализируется GUI и отображает экран входа. Пользователь вводит имя пользователя и пароль, которые аутентифицируются через Security Accounts Manager (SAM). После успешной аутентификации загружается рабочий стол пользователя.

[^1]: MBR и GPT это разные схемы разделов для дисков. MBR это старая схема, ограничивающая диск до 2 ТБ и поддерживая 4 основных раздела. GPT – таблица разделов, работающая с глобально уникальными идентификаторами GUID (Globally Unique Identifier). Это современная схема, поддерживая огромные диски и до 128 разделов.

##### Этапы загрузки Linux:
1) BIOS/UEFI выполняет POST и загружает MBR с загрузочного диска. В этой записи содержится программа. которая запускает вторичный загрузчик, например GRUB (GRand Unified Bootloader) (их существует много), который читает конфигурационные файлы, чтобы узнать доступные ОС и т.п.
2) GRUB отображает различные варианты загрузки, позволяющие пользователю выбрать различные режимы восстановления и так далее.
3) Запускается начальный код ядра. Читаются конфигурационные файлы, для определения устройств ввода-вывода, и добавляются в таблицу устройств.
4) Далее GRUB загружает само ядро Linux и начальный RAM-диск (специальная файловая система для загрузки ОС) в память, передавая управление ядру. Его начальный код, написанный на ассемблере, определяет тип процессора, вычисляет доступную RAM, отключает прерывания, активирует MMU и вызывает процедуру, написанную на C, для продолжения запуска ядра.
5) После инициализации ядра система начинает конфигурацию оборудования. Загружаются драйверы. Ядро запускает процесс 0. который продолжает инициализацию, включая настройку таймеров, монтирование корневой файловой системы, и создания процесса 1 (init) и процесса-демона страниц (процесс 2). init, в зависимости от флагов, запускает систему в однопользовательском или многопользовательском режиме, запуская скрипты инициализации.
6) Далее init запускает программу getty, которая настраивает свойства терминала и отображает приглашение для ввода. Когда пользователь вводит имя, getty выполняет /bin/login, который запрашивает пароль и сравнивает его с информацией из /etc/passwd.

До этапа загрузки ядра процессор работает в реальном режиме (16 бит), затем переключается в защищенный (32 или 64 бит).

#### 37. Инсталляция и конфигурирование многопрограммной многопользовательской ОС с графическим интерфейсом (на примере Windows,). Требования к аппаратным ресурсам. Подготовка процесса инсталляции. Конфигурирование разделов на жестком диске. Выбор файловой системы. Выбор варианта установки (локальная, сетевая). Инсталляция мультиоперационных систем.

##### Локальная установка Windows:

1) Проверить устройство на соответствие минимальным требованиям: процессор 1ГГц, 2 Гб (64-разрядная версия) или 1 Гб (32-разрядная) ОЗУ, 32 Гб дискового пространства.
2) Для установки необходимо создать загрузочный носитель. Оптимальным вариантом является флешка. Она должна быть не менее 8 Гб. Для создания такого носителя необходимо установить специальную программу Media Creation Tool и следовать инструкциям в ней.
3) В BIOS/UEFI нужно выбрать в качестве boot device это загрузочное устройство, и тогда ОС начнёт загружаться.

##### Сетевая установка Windows:

1) Необходимо настроить WDS на сервере. Он нужен чтобы клиенты обращались к нему и получали загрузочные образы.
2) Далее нужно настроить PXE, чтобы машина могла загружаться по сети. Компьютер запрашивает загрузочный образ у сервера, получает и начинает установку Windows.
Такой способ удобен для массовой установки в корпоративных средах.

##### Конфигурирование разделов:

Во время установки можно создать разделы на жёстком диске. Для этого нужно выбрать пользовательский режим установки и создать новый раздел. Также это возможно сделать через консоль. Для этого нужно открыть её (Shift + F10) и ввести команду `diskpart`. Далее можно посмотреть список дисков (`list disk`), выбрать нужный (`select disk <номер_диска>`) и создать раздел (`create partition primary size=n`).

##### Выбор файловой системы:

Windows 10 по умолчанию использует файловую систему NTFS, которая является хорошим выбором. Также Windows поддерживает FAT, но это немного устаревший формат, поэтому не рекомендуется форматировать диски под него.

##### Инсталляция мультиоперационных систем:

Для установки нескольких ОС (например двух) необходимо предварительно создать разделы диска под каждую ОС. Затем необходимо по очереди установить ОС. Если первая ОС не отображается, нужно использовать инструменты для восстановления загрузчика (Boot-Repair в Linux).

#### 38 - 39. Концепция процессов и потоков. Определение и модель процесса. Создание и завершение процессов. Иерархия процессов. Операции над процессами. Состояния процесса: выполнение, приостановка, возобновление. Блок управления процессами. Алгоритмы планирования.

**Процесс** — это экземпляр исполняемой программы (абстракция исполняемой программы), включающий текущие значения счетчика команд, регистров и переменных. Процесс состоит из нескольких частей: текстовый сегмент, в котором содержится исполняемый код программы, сегмент данных, в котором хранятся данные, необходимые для работы программы и сегмент стека (контекст), в котором хранится контекст вызова, например, переменные окружения и команду, с помощью которой была запущена программа (так она сможет понять, с какими аргументами её запустили).


Виртуальное адресное пространство процесса делится на User Space и Kernel Space. Первое используется, когда процесс работает в пользовательском режиме, а второй — в режиме ядра. В них хранятся данные для работы каждого режима.

Текстовый сегмент находится в самой нижней части пространства. За ним располагаются два сегмента данных: первый для инициализированных переменных, второй для неинициализированных. Ещё выше находится куча (Heap). Она используется для динамически выделяемых данных (размер или срок жизни которых нельзя предсказать на этапе компиляции (массивы, списки, хэш-таблицы)). В самом верху пространства пользователя находится стек, который хранит информацию о вызовах функций и системных вызовах. (Такая схема актуальна для 32-битных систем (у каждого процесса есть возможность обратиться только к $2^{32}$ адресам), у 64-битных систем адресное пространство может включать в себя до 128 Тб, т.к. для адресации используется всего лишь 48 бит)
![[Process scheme.png]]

**Потоки** — аналоги процессов, которые делят память внутри одного процесса. (дальше есть более подробная информация про них)

##### Состояния процесса:

У процесса может быть 3 основных состояния:
- **Выполнение** — процесс использует CPU.
- **Готовность** — процесс ждёт пока его выберет планировщик.
- **Блокировка** — процесс ожидает какого-то события, например, завершения операции ввода/вывода.

Также существует семиступенчатая модель:
- **Новый** — процесс только что создан.
- **Готов** — загружен в основную память, ждет свободного CPU.
- **Выполняется** — процесс использует CPU.
- **Заблокированный/ожидающий** — ожидает I/O, пользовательского ввода или критической секции.
- **Terminated/Completed** — убит или выполнен, ресурсы освобождены.
- **Приостановленный готовый** — готовый процесс, который выгружен на внешнее хранилище.
- **Приостановленный заблокированный** — заблокированный процесс, который выгружен на внешнее хранилище.

##### Создание процесса и завершение процесса


Создание процесса может произойти через:
- Инициализацию самой ОС (например init при старте системы).
- Создание процесса как дочернего от какого-то другого (fork).
- Создание процесса по запросу пользователя (например какая-нибудь команда в bash).
- Инициализацию пакетного задания. Это происходит в мейнфреймах и вычислительных центрах, где пользователи подготавливают задания, которые загружаются в файл и помещаются в очередь. ОС запускает процессы из этой очереди, таким образом инициатором создания является система, но по предварительной заявке пользователя.

Варианты завершения процесса:
- Нормальное завершение (добровольно) — вызов команды exit(0) (0 - код штатного завершения), процесс добровольно выходит, выгружая свои ресурсы.
- Выход при возникновении ошибки (добровольно) — процесс завешается с кодом ошибки.
- Возникновение критической ошибки (принудительно) — ОС принудительно завешает процесс из-за критической ошибки, например, сегфолта или деления на ноль.
- Завершение из другого процесса (принудительно) — внешний процесс завершает данный с помощью сигнала SIGKILL.

##### Системные вызовы для управления процессами:
- `pid=fork()` — создать дочерний процесс, идентичный родительскому.
- `pid=waitpid(pid, &statloc, opts)` — ждать завершения дочернего процесса.
- `s=execve(name, argv, envp)` — заменить образ памяти процесса.
- `exit(status)` — завершить выполнение процесса и вернуть статус.
- `s=sigaction(sig, &act, &oldact)` — определить действие, выполняемое при приходе сигнала.
- `s=kill(pid, sig)` — послать сигнал процессу.

fork() — системный вызов, который создаёт точную копию родительского процесса, включая адресное пространство. fork() возвращает значение, равное нулю, если выполняется в дочернем процессе и PID дочернего процесса, если в родительском.

После fork(), у родительского процесса обычно вызывается waitpid, который ждёт завершения дочернего процесса (если указать PID, то будет ждать определённого, если -1, то любого). Для дочернего процесса вызывается `execve`, который заменяет образ памяти (который наследовался от родителя) на программу, которую должен выполнять дочерний процесс.

Упрощенный пример оболочки:
```
while (TRUE) {
    /* бесконечный цикл */

    type_prompt();                   /* вывести приглашение к вводу */
    read_command(command, params);  /* прочитать с клавиатуры строку ввода */

    pid = fork();                   /* ответвить дочерний процесс */

    if (pid < 0) {
        printf("Создать процесс невозможно");  /* ошибка */
        continue;                              /* повторить цикл */
    }

    if (pid != 0) {
        waitpid(-1, &status, 0);   /* родительский процесс ждет дочерний процесс */
    } else {
        execve(command, params, 0);  /* дочерний процесс выполняет работу */
    }
}
```

##### Иерархия процессов:

Все процессы происходят от корневого процесса init. Они инициализируются путём вызова fork. Также могут быть осиротевшие процессы (если родительский процесс завершился), они становятся детьми init.

##### Блок управления процессами:

Процессы хранятся в таблице процессов. Каждая запись в ней называется PCB. Таблица страниц не может быть выгружена.

**PCB (Process Control Block)** — это структура данных (дескриптор процесса), которую операционная система использует для хранения информации о процессе.

PCB содержит данные и указатели на области:
- PID.
- Текущее состояние процесса (например, Ready, Running, Blocked).
- Счетчик команд (Program Counter), который указывает на следующую инструкцию для выполнения.
- Регистры процессора.
- Указатели на сегменты текста, данных и стека.
- Список открытых файлов и дескрипторов.
- Статус ввода-вывода.

##### Алгоритмы планирования
Алгоритмы [здесь](Планирование)

#### 40. Обработка прерываний.

**Прерывание** — это сигнал, который прерывает нормальный поток выполнения процессора, требуя немедленной обработки.

##### Классификация прерываний:

- **Внешние** (аппаратные) — возникают от внешних устройств: таймеры, устройства ввода/вывода. Называются асинхронными, ведь процессор не знает в какой момент они произойдут.
- **Внутренние** — вызываются самим процессором, например, при делении на ноль, обращении к недоступному адресу или переполнении стека. Называются синхронными так как они предсказуемо связаны с потоком выполнения программы. Если повторно выполнить программу, прерывание произойдёт в том же месте.
- **Программные** — инициализируются инструкциями. Например INT (ассемблер) (от interrupt) в x86 архитектуре процессоров. Команда буквально инициирует переход к обработчику прерываний с заданным номером. Номер обозначает к какому обработчику идёт обращение. 
- **Маскируемые** — некоторые прерывания могут быть отключены программно. Процессор будет их просто игнорировать.
- **Немаскируемые** — прерывания, которые нельзя отключить.


##### Механизм обработки прерываний:

1) **Обнаружение**. Процессор мониторит линии прерываний, чтобы обнаружить сигнал.
2) **Подтверждение**. При получении сигнала, процессор оповещает устройство, которое его вызвало, о начале обработки, чтобы оно прекратило посылать сигнал.
3) **Сохранение контекста**. Прерывание — это переключение контекста процессора, поэтому необходимо сохранить его текущее состояние, чтобы позже к нему вернуться.
4) **Переход к обработчику**. Находится нужный обработчик и осуществляется переход к нему.
5) **Выполнение**. Обработчик выполняет необходимые действия.
6) **Восстановление**. Восстанавливается сохранённое состояние процессора и возобновляется выполнение.

#### 41. Ядро операционной системы.

**Ядро операционной системы** — это центральный компонент, который управляет ресурсами компьютера и обеспечивает взаимодействие между аппаратным и программным обеспечением. Оно действует как низший уровень абстракции, позволяя приложениям получать доступ к необходимым ресурсам через межпроцессное взаимодействие и системные вызовы.

##### Основные функции ядра:

###### Управление процессами:

Ядро отвечает за создание, планирование и завершение процессов. Также ядро может управлять и потоками (если они реализованы на уровне ядра).

###### Управление памятью:

Ядро выделяет и освобождает память для процессов, управляет виртуальной памятью и обеспечивает изоляцию адресных пространств процессов.

###### Управление устройствами:

Через [драйверы](Драйверы)  ядро взаимодействует с аппаратными компонентами ввода/вывода, такими как клавиатуры, мониторы, сетевые карты и т.д.

###### Управление файловой системой:

Ядро предоставляет интерфейс для взаимодействия с файлами и каталогами, обеспечивая доступ к данным на различных носителях (HDD/SSD). Оно выполняет операции чтения, записи, удаления файлов.

###### Управление сетью:

Ядро реализует сетевые протоколы и обрабатывает пакеты.

###### Системные вызовы и безопасность:

Организация обращений к ядру через системные вызовы обеспечивает безопасность, предотвращая несанкционированный доступ к ресурсам и защищая само ядро от вмешательства приложений. Системные вызовы производятся при помощи прерываний.

#### 42. Потоки и их использование. Модель потока. Реализация потоков в пространстве пользователя. Реализация потоков в ядре. Смешанная реализация. Активация планировщика.

**Потоки** — это последовательные потоки выполнения задач внутри процесса, которые позволяют разделить процесс на независимые задачи. Они делят с процессом код, данные и ресурсы операционной системы, такие как открытые файлы, но имеют собственный стек, счетчик программы и набор регистров. Из-за общих данных поток создаётся гораздо быстрее чем процесс (не надо выделять память или создавать объёмные PCB).

##### Реализация потоков на уровне пользователя:

Потоки в пространстве пользователя (User-Level Threads, ULT) управляются библиотекой в пространстве пользователя, без вмешательства ядра.

**Преимущества:**
- Из-за того, что ядро не вмешивается (не происходит постоянного переключения контекстов), создание, уничтожение и переключение между потоками происходит очень быстро.
- Такие потоки могут работать в ОС, в которой потоки не поддерживаются. Также из этого следует, что программист может сам написать логику планирования потоков.

**Недостатки:**
- Если один поток вызывает блокирующий вызов, блокируется весь процесс.
- Так как ядро видит только один поток (ULT как бы находятся внутри KLT, а при такой реализации KLT один), ОС не может планировать их работу по отдельности и распределять по разным процессорам.

##### Реализация потоков на уровне ядра:

Потоки в ядре (Kernel-Level Threads, KLT) управляются операционной системой и являются частью ядра.

**Преимущества:**
- Потоки могут выполнятся параллельно, на разных процессорах.
- Если один поток делает блокирующий системный вызов, то остальные потоки продолжают работать.

**Недостатки:**
- Большие накладные расходы (переключение контекста), соответственно операции над ними производятся медленнее.
- Ядро может ограничивать допустимое количество потоков.

##### Смешанная реализация:

Смешанная реализация (Many-to-Many Model) сочетает пользовательские и ядерные потоки, обеспечивая гибкость и производительность. Библиотека в пространстве пользователя управляет пользовательскими потоками, а ядро управляет потоками ядра, обеспечивая координацию между уровнями.

Сочетает преимущества двух реализаций, но требуют сложной координации между пользовательским и ядерным уровнем.

##### Модель потока:

Модель определяет, как потоки взаимодействуют с процессом и ОС. В любой модели KLT содержит в себе ULT (например как процессы содержат потоки). Это означает что ОС может взаимодействовать только с наружной частью (KLT).

- **Многие-к-одному** — управление потоками осуществляется библиотекой в пространстве пользователя, что делает создание и переключение потоков быстрым (из-за отсутствия переключения контекста), но если один поток выполнит блокирующий вызов, заблокируется весь процесс. Т.е. это реализация потоков на уровне пользователя.
- **Один-к-одному** — каждый пользовательский поток имеет поток ядра. Можно сказать что это просто реализация потоков на уровне ядра.
- **Многие-ко-многим** — гибридная модель, где многие пользовательские потоки отображаются на равное или меньшее количество потоков ядра. Это означает, что каждый поток ядра как бы содержит несколько потоков пользователя. Если один из пользовательских потоков выполняет блокирующий вызов, блокируется только поток уровня ядра, в котором он хранится (правильнее "которому соответствует"). Т.е. это смешанная реализация.

##### Активация планировщика:

**Scheduler Activations** — это механизм, при котором ядро и пользовательская библиотека потоков сотрудничают, чтобы обеспечить быстроту ULT и параллельность KLT.

При таком подходе применяются легковесные процессы (Lightweight Processes, LWP) (LWP это абстракция, выполняющая работу). В современных ОС можно сказать KLT = LWP. Предположим что у нас есть 20 ULT и 4 процессора, между которыми их нужно распределить.
Выделяется 4 LWP с помощью scheduler activations. LWP будет сообщать библиотеке потоков уровня пользователя о различных событиях. Предположим что на процессоре №2 ULP#4 заблокировался. Вместо того, чтобы блокировать весь LWP (который содержит и другие ULP), посылается upcall — сообщение библиотеке о том, что один из её потоков заблокировался и что нужно выбрать новый. Библиотека должна решить какой поток ставить вместо заблокированного. Таким образом остаются положительные стороны двух реализаций потоков, но для этого нужно реализовать крайне сложную систему как со стороны ядра ОС, так и со стороны библиотеки

#### 43. Всплывающие потоки (нити). Возможности создания многопоточных программ. Концепция волокон.

**Всплывающий поток (pop-up thread)** — это поток, который автоматически создаётся системой при поступлении входящего сообщения (например, сетевого запроса), исключительно для обработки этого сообщения.

Основное преимущество данных потоков заключается в быстроте. Они создаются с чистого листа, без необходимости восстанавливать регистры, стек и другие данные. Из-за этого их используют в распределённых системах и серверах.  (они минимизируют задержку между поступлением сообщения и началом его обработки, обеспечивая быстрый отклик).

##### Возможности создания многопоточных программ:

Создание многопоточных программ возможно из-за широкого набора инструментов, предоставляемых различными языками программирования и операционными системами. Они позволяют создавать мьютексы, семафоры и другие структуры для управления общим доступом к ресурсам.

##### Концепция волокон:

**Волокна (fibers)** — это легковесные потоки, управляемые приложением, а не операционной системой. Это ULT.

#### 44. Взаимодействие и синхронизация процессов и потоков. Параллельные асинхронные процессы и межпроцессное взаимодействие. Уровни параллелизма: задания, задачи, процессы, потоки Состояния состязания.

**Процессы** во время своего выполнения могут взаимодействовать между собой через механизмы межпроцессорного взаимодействия (IPC).
**Потоки** также взаимодействуют между собой, только гораздо проще, ведь у них общее адресное пространство.

Но тут может возникнуть проблема синхронизации. Когда несколько процессов или потоков допускаются к общим ресурсам (например, разделяемой памяти), может возникнуть состояние состязания (race condition), если порядок доступа не контролируется.

**Состояния состязания (Race Conditions)** — состояние, когда два или более процесса или потока допускаются к общему ресурсу (например, разделяемой памяти) одновременно, и результат зависит от порядка их выполнения. Оно может привести к неопределённому поведению в программе.

**Параллельные процессы** — процессы, которые выполняются одновременно, что достигается за счет распределения задач по нескольким процессорам или ядрам.

**Асинхронные процессы** — процессы, которые не ждут завершения друг друга, а продолжают выполнение независимо. Они часто используется для задач с вводом-выводом или с удалёнными запросами.

**Межпроцессное взаимодействие (IPC)** — это обмен данными между процессами, которые могут работать на одном компьютере или в сети.

**Основные механизмы:**
- *Сокеты* — запись и чтение общего файла или сетевого соединения.
- *Каналы (pipe)* — односторонний поток между процессами.
- *Очереди сообщений* — процесс может поместить в очередь сообщение, а другой может его оттуда прочитать посредством системных вызовов, при условии того, что процессы используют одинаковый ключ доступа.
- *Разделяемая память* — область, общая для нескольких процессов.
- *Семафоры, мьютексы, мониторы* — про них написано дальше.

##### Уровни параллелизма:

**Задания (Jobs)** — наивысший уровень параллелизма. Это крупная единица работы, которая может быть разделена на задачи. Например, в пакетных системах задание может включать несколько программ, выполняемых последовательно или параллельно

**Задачи (Tasks)** — часть задания, которая может быть выполнена независимо. Они распределяются по процессам и потокам.

**Процессы (Processes)** — независимые единицы выполнения с собственным адресным пространством. Они выполняются на разных процессорах, таким образом достигается параллельная работа.

**Потоки (Threads)** — легковесные процессы, делящие адресное пространство в пределах одного процесса между собой. Потоки также могут выполняться на нескольких процессах.

#### 45. Взаимоисключения и критические участки. Примитивы и алгоритмы взаимоисключения.

**Взаимоисключение (mutual exclusion)** — это концепция, которая обеспечивает, что только один процесс или поток может получить доступ к общему ресурсу в один момент времени. Это необходимо для предотвращения состояний состязания (race conditions).

**Критические участки (critical sections)** — это части программного кода, где происходит доступ к общим ресурсам. Одновременный доступ к этим ресурсам без контроля может привести к состоянию состязания, где результат зависит от порядка выполнения операций. Например, если два процесса пытаются увеличить общий счетчик, один может перезаписать изменения другого, что приведет к потере данных.

Для предотвращения таких ситуаций необходимо обеспечить, чтобы только один процесс или поток мог находиться в критической секции в один момент времени. Это достигается с помощью механизмов взаимоисключения, которые гарантируют, что доступ к ресурсам строго упорядочен.

**Примитивы** — это базовые инструменты, используемые для реализации взаимоисключения. Они предоставляют низкоуровневые механизмы для управления доступом к критическим секциям. К ним относятся Семафоры, мьютексы, мониторы и аппаратные примитивы (Test-and-Set).

**Алгоритмы** — это методы, которые используют примитивы или другие техники для обеспечения того, чтобы только один процесс или поток мог войти в критическую секцию в один момент времени.

**Атомарные инструкции (atomic instructions)** — операции, которые выполняются полностью или не выполняются вовсе, без прерываний другими потоками. Если они начали своё выполнение, то они не могут быть прерваны.

- **Алгоритм Петерсона** — обеспечивает программное решение проблемы для *двух процессов*. Алгоритм использует две общие переменные, где каждый процесс устанавливает свой флаг, когда хочет зайти в критическую область, и переменную turn, которая указывает, чья очередь входить. У такого алгоритма есть недостатки: он работает только для двух конкурирующих потоков (процессов) и в нём присутствует активное ожидание (пустой цикл, который просто так нагружает процессор). Современные процессоры могут изменять последовательность доступа к памяти по своему усмотрению (для более эффективной работы), а для корректной работы алгоритма крайне важен порядок выполнения инструкций, поэтому такой подход сегодня и не используется (библиотека `atomic` из примера как раз исправляет эту проблему).
```
#include <atomic>

std::atomic<bool> flag[2];
std::atomic<int> turn; // доступ должен быть атомарным

void enter_critical(int id) {
    int other = 1 - id;
    flag[id] = true;
    turn = other;
    while (flag[other] && turn == other); // ожидание
}

void exit_critical(int id) {
    flag[id] = false;
}
```

- **Алгоритмы на основе токенов (Token-based Algorithms)** — только процесс, владеющий токеном, может войти в критическую секцию. Принцип, похожий на [[Token Ring]].
- **Алгоритмы на основе кворумов (Quorum-based Algorithms)** — процесс должен получить разрешение от большинства (кворума) других процессов, чтобы войти в критическую секцию.

#### 46. Семафоры, мониторы, передача сообщений. Проблемы межпроцессного взаимодействия.

**Спин блокировки (spinlock)** — механизм, который постоянно проверяет, свободна ли блокировка, не покидая CPU. Spinlock это механизм, который служит основой для более сложных структур (для [семафоров](Семафоры), [мьютексов](Мьютексы), [мониторов](мониторы)).

```
struct spinlock_t {
    int acquired = 0; // какой-то объект, у которого есть атрибут acquired (занят)
};

// Это демонстрационная реализация аппаратной атомарной функции
// она должна выполняться как одна неделимая инструкция
int TestAndSet(int* val) {
    int oldValue = *val;
    *val = 1;
    return oldValue;
}

void Lock(spinlock_t* s) {
    while (TestAndSet(&s->acquired)); // активное ожидание
}

void Unlock(spinlock_t* s) {
    s->acquired = 0;
}
```

##### Проблемы межпроцессного взаимодействия:

- **Состояния состязания (Race Conditions)** — возникают, когда несколько процессов или потоков одновременно обращаются к общим ресурсам (например, разделяемой памяти) без надлежащей синхронизации.
- **Блокировки (Deadlocks)** — возникает, когда два или более процесса блокируют друг друга, ожидая освобождения ресурсов.
- Накладные расходы — синхронизация IPC требует дополнительных вычислительных ресурсов, таких как системные вызовы для управления семафорами.
#### 47. Ресурсы и их захват процессами. Выгружаемые и невыгружаемые ресурсы. Примеры тупиков при распределении ресурсов. Обнаружение и предотвращение тупиков. Алгоритмы разрешения тупиков. Восстановление после тупиков.

Deadlock это всё-таки "взаимоблокировка" а не "тупик", поэтому я буду использовать этот термин.

**Ресурс** — это объект, который необходим процессу для выполнения.
Процессы запрашивают ресурсы через системные вызовы, и если ресурс доступен, он выделяется. Если ресурс занят, процесс может ждать, что иногда приводит к взаимоблокировкам, особенно если процесс уже удерживает другие ресурсы.

##### Выгружаемые и невыгружаемые ресурсы:

**Выгружаемые ресурсы** — ресурсы, состояние которых можно легко сохранить и восстановить, что позволяет операционной системе отобрать их у процесса. Примером может служить память или CPU.

**Невыгружаемые ресурсы** — те, которые нельзя отобрать у его текущего владельца, не вызвав потенциально сбоя в вычислениях. Например, принтеры, открытый файл.

##### Примеры взаимоблокировок:

Предположим что каждый из двух процессов захотел записать отсканированный документ на Blu-ray диск. Процесс `A` запрашивает разрешение на использование сканера и получает его. Процесс `B` запрограммирован по-другому: он сначала запрашивает разрешение на использование пишущего Blu-ray привода и получает его. Затем процесс `A` запрашивает разрешение на использование привода, но получает отказ, ведь он занят другим процессом. В свою очередь `B` запрашивает доступ к сканеру, на что получает отказ, ведь он держится процессом `A`. В этот момент процессы оказываются заблокированными навсегда. Такая ситуация называется взаимоблокировкой.

##### Обнаружение взаимоблокировок:

Обнаружение взаимоблокировок включает проверку графа выделения ресурсов на наличие циклов. Если он обнаружен, значит в системе взаимоблокировка.

![[Resource dependencies graph.png]]


##### Условия возникновения взаимоблокировок:

- *Условие взаимного исключения.* Каждый ресурс либо выделен в данный момент только одному процессу, либо доступен. (Процесс `A` держит принтер и процесс `B` не может захватить его. Если бы ресурсы были разделимыми, то процесс `B` мог бы захватить принтер и потенциальной блокировки можно было бы избежать. С принтером такое вряд ли выйдет сделать, но так можно использовать другие ресурсы, например делая их доступными только для чтения.)
- *Условие удержания и ожидания.* Процессы, удерживающие в данный момент ранее выделенные им ресурсы, могут запрашивать новые ресурсы.
- *Условие невыгружаемости.* Ранее выделенные ресурсы не могут быть принудительно отобраны у процесса. Они должны быть явным образом высвобождены тем процессом, который их удерживает.
- *Условие циклического ожидания.* Должна существовать кольцевая последовательность из двух и более процессов, каждый из которых ожидает высвобождения ресурса, удерживаемого следующим членом последовательности.

Есть два подхода к взаимоблокировкам: предотвращение и избегание.

##### Предотвращение взаимоблокировок:

Если "разрушить" хотя бы одно из условий возникновений взаимоблокировок, то она будет невозможна.

- **Атака условия взаимного исключения**. Цель: сделать ресурсы одновременно доступными для нескольких процессов. Это достигается за счёт доступа только для чтения. Так процессы не смогут друг другу помешать. Однако так можно сделать не со всеми ресурсами (например устройства вывода).
- **Атака на условие удержания и ожидания**. Цель: запретить удерживать один ресурс и при этом ждать другой. Процессы должны запрашивать все ресурсы до начала выполнения. Запросить ресурсы можно только в случает если нет уже захваченных ресурсов, иначе нужно отпустить и попробовать заново. Это сильно снижает эффективность.
- **Атака на условие удержания и ожидания**. Цель: сделать ресурсы прерываемыми, чтобы их можно было отобрать. Но не все ресурсы можно выгрузить.
- **Атака на условие циклического ожидания**. Цель: не дать возникнуть циклу в графе ожиданий. Ресурсам назначаются номера. Процессы могут запрашивать номера только в возрастающем порядке. Это требует дополнительного проектирования и более сложной логики приложения.

##### Алгоритмы избегания взаимоблокировок:

- **Страусиный алгоритм** (не совсем алгоритм, но про это лучше упомянуть) — самый простой способ это игнорирование проблемы. Такой способ подходит не для всех систем (если нужна абсолютная стабильность, то этот способ не подойдёт). Он используется в большинстве десктопных ОС. Постоянный мониторинг системы на наличие взаимоблокировок и их устранение это требовательные процессы. В среднем система переходит в состояние deadlock раз в 2 года. При таком раскладе будет проще перезагрузить компьютер один раз, чем два года терпеть лишнюю трату вычислительных ресурсов.
- **Траектории ресурса** — графическое представление, показывающее возможные состояния системы при последовательном выделении ресурсов. Есть небезопасные зоны, в которых может возникнуть взаимоблокировка, и безопасные зоны, в которых её можно избежать. Идея в том, чтобы не заходить в эти зоны на графике.
- **Алгоритм банкира** — у каждого процесса есть переменные: `m` = максимальное количество ресурса, которое он может запросить; `c` = сколько выделено ресурсов процессу сейчас. "Банкир" может удовлетворить запрос процесса только в случае если `m` + `a` <= доступного количества ресурса всего. В случае если нужно регулировать ситуацию со многими ресурсами, то алгоритм остаётся тот же, просто информация хранится в виде матриц.

##### Восстановление после тупиков:

- Восстановление за счет приоритетного овладения ресурсом. ОС может просто отобрать ресурс у одного процесса и отдать другому.
- Восстановление путем отката. Отката до контрольной точки, в которой не было deadlock.
- Восстановление путем уничтожения процессов. Нет процессов — нет проблем).



#### 48. Моделирование на языках высокого уровня вычислительного процесса многопрограммных операционных систем с детализацией уровней задач, процессов, потоков и тупиков.

#### 49. Мультипрограммирование. Аппаратно-программные средства поддержки мультипрограммирования.

**Мультипрограммирование** — это способ организации вычислений, при котором в оперативной памяти одновременно находятся несколько программ (процессов), и процессор переключается между ними, чтобы обеспечить эффективное использование ресурсов. Например, когда один процесс ожидает ввода/вывода, процессор переключается на другой процесс.

##### Аппаратные средства поддержки:

- **Изоляция памяти**. Из-за механизма виртуальной памяти каждый процесс обладает собственным адресным пространством, и другие процессы не могут повредить его при переключении. Виртуальная память поддерживается MMU.
- **Прерывания**. При переключении между процессами происходит прерывание, которое аппаратно поддерживается процессорами.
- **Ядра**. Большое количество ядер на современных процессорах существуют как раз для поддержки мультипрограммирования.

##### Программные средства поддержки:

- **Планировщик**. Обеспечивает эффективное использование процессоров.
- **Таблицы процессов**.
- **Механизмы синхронизации**. Нужны чтобы не возникало конфликтов между процессами.
- **Буферизация ввода/вывода**.

#### 50. Иерархическая организация памяти. Функции ОС по управлению памятью. Задачи распределения памяти. Алгоритмы распределения памяти. Распределение фиксированными и динамическими разделами.

##### Иерархическая организация памяти:

Память организована иерархически по скорости и объёму:
- **Регистры процессора** — самый быстрый и небольшой по объёму тип памяти. Предназначены для хранения временных данных, нужных процессору для вычислений.
- **Кеш-память** (L1 L2, L3). Больше и медленнее регистров. Используется для ускорения доступа к ОЗУ.
- **ОЗУ** — основная память компьютера. В ней хранятся данные запущенных программ.
- **Диски** — самая медленная и объёмная память. Используется для долгосрочного хранения данных.

##### Функции ОС по управлению памятью:

- **Выделение и освобождения памяти**. ОС выделяет память процессам при их запуске и освобождает ее после завершения работы.
- **Защита памяти**. Обеспечивает изоляцию адресного пространства каждого процесса.
- **Управление виртуальной памятью**. Это позволяет эффективно использовать RAM.
- **Минимизация фрагментации**.

##### Задачи распределения памяти.

По сути функции ОС выполняют задачи.

- **Эффективное использование памяти**. Максимально использовать доступное пространство.
- **Поддержка многозадачности**. Обеспечивать одновременный доступ к памяти для нескольких процессов.
- **Защита данных**.

##### Алгоритмы распределения памяти:

- **First Fit (Первый подходящий)**. Выделяет первый свободный блок памяти, который достаточно велик для запроса. Простой, но может привести к фрагментации.
- **Best Fit (Лучший подходящий)**. Выделяет самый маленький свободный блок, который подходит для запроса. Минимизирует отходы, но требует больше времени на поиск.
- **Worst Fit (Худший подходящий)**. Выделяет самый большой свободный блок. Может оставлять большие свободные области, но помогает избежать фрагментации в долгосрочной перспективе.
- **Next Fit (Следующий подходящий)**. Аналогичен First Fit, но начинает поиск с места последнего выделения. Полезен для систем с частыми запросами.

##### Распределение фиксированными и динамическими разделами:

**Фиксированные разделы (Fixed Partitioning)** — память делится на фиксированное количество блоков фиксированного размера при запуске системы. Каждый блок выделяется отдельному процессу (если одного блока не хватает для процесса, память просто не выделится). При таком подходе отсутствует внешняя фрагментация, зато сильно распространена внутренняя.

**Динамические разделы (Dynamic Partitioning)** — память делится на блоки переменного размера в зависимости от потребностей процессов. Блоки создаются и удаляются динамически. Это минимизирует внутреннюю фрагментацию, но может возникнуть внешняя. Как раз здесь используются алгоритмы распределения памяти.

#### 51. Алгоритмы памяти. Свопинг.

Алгоритмы выделения памяти были раньше.

**Свопинг** — это техника управления памятью, при которой данные или программы перемещаются между RAM и вторичным хранилищем, например, жестким диском или SSD, для управления ограниченным пространством RAM. Это позволяет запускать больше программ, чем может позволить физическая память. Свопинг применяется со страничной организации памяти и сегментацией.

Процесс свопинга (на примере с сегментацией):
1) Выбор неактивного процесса, когда RAM заполнена.
2) Перемещение этого процесса на диск, освобождая место в ОЗУ.
3) Если процесс снова активируется, то его можно будет загрузить с диска, возможно выгрузив неактивный процесс.

Свопинг может применяться не только для областей памяти процессов, но и для страниц (page swapping).

Свопинг это крайне требовательный процесс, сильно влияющий на производительность.

#### 52. Кэширование (в ОС).

**Кэширование** — это способ хранения часто используемых данных в быстрой памяти, например, в RAM, чтобы ускорить доступ к ним.


- **Файловый кэш**. Когда приложение запрашивает файл, ОС сначала проверяет, есть ли он в файловом кэше. Если да, данные возвращаются быстро из RAM, а не считываются с диска. В нём также применяется отложенная запись (lazy writing), когда данные записываются на диск с интервалами, что улучшает производительность, но увеличивает риск потери данных при сбоях.
- **Дисковый кэш**. Часто используется в файловых системах для хранения данных, которые недавно были прочитаны или записаны, чтобы ускорить последующие операции.

Кэширование уменьшает количество обращений, например, к ОЗУ, что снижает задержки и продлевает срок службы устройства. Но в то же время кэш требуют хороших алгоритмов для эффективной работы.

Про TLB будет дальше.

#### 53. Виртуальная память. Страничная, сегментная и сегментно-страничная организация памяти.

[[Виртуальная память]]

**Виртуальная память** — концепция, позволяющая программам работать с адресным пространством, превышающим объем физической памяти. Она обеспечивает изоляцию процессов, упрощает управление памятью и повышает эффективность использования ресурсов.

##### Страничная организация памяти:

Делит память на страничные блоки фиксированного размера, называемые страницами. 

Страницы могут находиться в физической памяти (тогда они называются страничными блоками) или быть выгруженными на диск (чтобы не занимать место). Информация о размещении страничных блоков находится в *таблице страниц*. Номер виртуальной странице является в ней ключом, а значением — смещение. Также в ней есть бит присутствия (valid). Если при обращении к таблице страниц, она оказывается выгруженной, то происходит page fault и эта страница загружается с диска. Для ускорения обращений существует TLB (translation lookaside buffer). Его можно рассматривать как кэш, только он содержит не сами данные (смещения), а расположения нужных страниц в таблице страниц. Преобразованием виртуальных адресов занимается MMU. (это если коротко, основная информация [тут](Виртуальная память))

##### Сегментная организация памяти:

**Фиксированные разделы (Fixed Partitioning)** — память делится на фиксированное количество блоков фиксированного размера при запуске системы. Каждый блок выделяется отдельному процессу (если одного блока не хватает для процесса, память просто не выделится). При таком подходе отсутствует внешняя фрагментация, зато сильно распространена внутренняя.

**Динамические разделы (Dynamic Partitioning)** — память делится на блоки переменного размера в зависимости от потребностей процессов. Блоки создаются и удаляются динамически. Это минимизирует внутреннюю фрагментацию, но может возникнуть внешняя. Как раз здесь используются алгоритмы распределения памяти.

У каждого сегмента есть базовый адрес (его начало) и предел (его конец). При обращении по виртуальному адресу, складывается виртуальный адрес (смещение) и базовый адрес. Так получается физический адрес. Информация о сегментах хранится в таблице сегментов.

При сегментной организации возникают проблемы фрагментации и производительности (из-за свопинга).

##### Сегментно-страничная организация памяти:

Виртуальное адресное пространство делится на сегменты, каждый сегмент – на страницы. Виртуальный адрес состоит из номера сегмента, номера страницы и смещения. MMU выполняет двухэтапное преобразование. Устраняется проблема фрагментации, но требует сложного преобразования. Также необходимо хранить две таблицы страниц.

#### 54. Выбор размера страниц. Выбор величины файла подкачки и его размещения (на примере Windows). Защита памяти.

Размер страницы в системе виртуальной памяти определяет, на какие блоки фиксированного размера делится виртуальное и физическое адресное пространство. В Windows стандартный размер страницы составляет **4 КБ** (4096 байт) для большинства архитектур (x86, x64), хотя в некоторых случаях поддерживаются большие страницы (например, 2 МБ или 1 ГБ).

##### Выбор размера страниц:

**Небольшой размер страниц:**
- Использование небольших размеров страниц уменьшает внутреннюю фрагментацию.
- Загрузка страниц происходит быстрее.
- Большая таблица страниц, в которой дольше производить поиск.
- TLB также сможет содержать меньше полезной информации.

**Большие страницы:**
- Внутренняя фрагментация.
- Меньше обращений к диску.
- Проще поиск по таблице страниц.
- Большее покрытие TLB (промахи случаются реже).

При выборе размера страниц также следует учитывать поддерживаемые процессором размеры страниц. У Intel x86 это 4Кб, 2Мб и 1Гб.

##### Выбор величины файла подкачки и его размещения:

Файл подкачки (pagefile.sys) в Windows — это скрытый системный файл, который используется для хранения страниц виртуальной памяти, когда физическая оперативная память (RAM) заполнена. Он также необходим для создания дампов памяти при сбоях системы (например, Blue Screen of Death).

По умолчанию Windows сам управляет размерами файла подкачки, но его также можно настроить вручную. Рекомендуется ставить от 1.5x до 3x размера ОЗУ (оптимальное 2x).

При размещении файла подкачки нужно выбрать диск с подходящим доступным объемом памяти. Также желательно разместить его на SSD. Также хорошей практикой является размещение на отдельном физическом диске, чтобы уменьшить конкуренцию за дисковые ресурсы.
##### Защита памяти:

Виртуальное адресное пространство включает в себя изоляцию адресного пространства каждого процесса, защищая его от несанкционированного доступа. Также у каждой страницы есть свои атрибуты доступа (rwx), определяющие доступные над ними действия. Перед обращением к странице MMU проверяет, можно ли выполнить команду и если нет, выдаёт исключение.

#### 55. Аппаратная поддержка механизма виртуальной памяти. Преобразование виртуальных адресов в физические.

##### Аппаратная поддержка механизма виртуальной памяти:

Аппаратным средством поддержки виртуальной памяти является MMU. Его основными задачами являются быстрое преобразование адресов и изоляция памяти.

##### Преобразование виртуальных адресов:

Представим 32-разрядную систему, с адресами в 32 бита. Современные таблицы страниц являются многоуровневыми с целью экономии памяти. Из-за этого виртуальный адрес разделяется на части: 10 бит для таблицы страниц верхнего уровня (Page Directory), 10 бит — для таблицы второго уровня (Page Table) и 12 бит — на смещение внутри страницы. Первая часть выбирает таблицу страниц, а второй саму страницу.

![[Page Table.png]]

![[Virtual --- Physical.png]]

На этой схеме 16-разрядное адресное пространство, но принцип тот же, просто в 32-разрядной системе ключами к смещению были бы сначала 10 бит адреса таблицы страниц, а затем 10 бит адреса самой страницы.

в 64-разрядной системе используются только 48 бит. По 9 бит на каждый уровень таблиц:
- PML4 — Page Map Level 4
- PDPT — Page Directory Pointer Table
- PD — Page Directory
- PT — Page Table

Перед обращением к таблице страниц MMU проверяет **Translation Lookaside Buffer (TLB)** — небольшой кэш, который хранит недавние преобразования виртуальных адресов в физические.
**TLB hit**: Если VPN найден в TLB, MMU немедленно получает соответствующий физический номер страницы (PPN) и переходит к формированию физического адреса.
**TLB miss**: Если VPN отсутствует в TLB, MMU выполняет поиск в таблице страниц, что занимает больше времени.

Если в TLB нет соответствия, MMU обращается к **таблице страниц**, которая хранится в оперативной памяти. Если номер не находится и там, то обращение идёт к файлу подкачки, который хранится на диске.

![[MMU actions.png]]

После получения PPN из таблицы страниц или TLB MMU комбинирует его со смещением из виртуального адреса, чтобы сформировать физический адрес.

Если запись в таблице страниц указывает, что страница отсутствует в физической памяти (например, она находится на диске), MMU генерирует **ошибку страницы (page fault)**. Это прерывание передаётся операционной системе. Она обновляет таблицу страниц, добавляя в неё новую запись и возвращает управление MMU.


#### 56. Защита данных при сегментной организации памяти. Исследование виртуальной памяти.

Кажется тут имелось в виду "Исследования в области виртуальной памяти".
##### Защита данных при сегментной организации памяти:

Сегментная организация памяти предполагает разделение адресного пространства на сегменты переменного размера, каждый из которых соответствует логической части программы, такой как код, данные или стек.

Каждый сегмент имеет базовый адрес и размер (лимит), которые определяют допустимый диапазон адресов. Блок управления памятью (MMU) проверяет, что любой запрос к памяти находится в пределах разрешенного сегмента. Также проверяются атрибуты доступа к сегменту (rwx).

##### Направления исследований в области виртуальной памяти:

- **Оптимизация преобразования адресов** —  исследования, направленные на:
	- Улучшения алгоритмов TLB (для увеличения количества TLB hit).
	- Организацию и применения многоуровневых таблиц страниц.
	- Использование разных размеров страниц.
- **Подкачка** — исследуются алгоритмы замены страниц. Также интересным направлением является сжатие редко используемых страниц прямо в RAM.
- **Защита памяти**
- **Поддержка виртуализации** 
- **Оптимизация работы с большими объёмами памяти** — в современных мейнфреймах могут быть терабайты оперативной памяти. Для лучшей работы с ними могут, например, сжиматься таблицы страниц.

#### 57. Принципы функционирования аппаратуры ввода-вывода. Устройства ввода-вывода и их контроллеры.

##### Устройства ввода-вывода:

**Устройства ввода-вывода** — это компоненты компьютерной архитектуры, которые обеспечивают обмен данными между компьютером и внешней средой.

Их можно разделить на две категории:
- Блочные устройства — хранят информацию в блоках фиксированной длины, у каждого из которого есть свой адрес. К каждому блоку можно обращаться независимо.
- Символьные устройства (иногда байт-ориентированные) — работают с потоком байтов. Адресация к каким-либо участкам недоступна.

##### Контроллеры:

**Контроллеры устройств ввода-вывода** — это электронные компоненты, которые управляют взаимодействием между устройством и центральным процессором (CPU). Они предоставляют удобный интерфейс для управлением аппаратным устройством. Процессор обращается к контроллеру устройств, которые уже взаимодействуют с аппаратной частью.

Контроллеры дисков могут обрабатывать ошибки чтения, выполнять буферизацию данных. Также они генерируют прерывания для процессора, чтобы он мог понимать, когда операция над устройством завершена. Драйвера помогают перевести команды ОС в команды для контроллера.

##### Принципы:

- **Асинхронность.** Обращения к устройствам ввода-вывода должны происходить асинхронно (процессор не ждёт завершения операции).
- **Прерывания.** Контроллеры генерируют прерывания для оповещения процессора о завершении операции/ошибке и т.д.
- **Буферизация.** Часто устройства временно сохраняют некоторые значения в специальном буфере (часто где-то в/возле контроллере(-ера)) для обеспечения более быстрого доступа к данным.
- **Очереди запросов.** Если устройство занято, то запросы к нему помещаются в очередь, которой управляет контроллер.
- **Стандартизация интерфейсов.** Современные устройства используют стандартные интерфейсы подключения (USB, SATA, PCIe).

#### 58. Понятие файла. Именование, структура и типы файлов. Атрибуты и доступ к файлам, операции с файлами.

**Файл** — это именованная коллекция связанной информации, хранящаяся на вторичных носителях данных. Они представляют из себя последовательность битов. Файлы служат основным способом хранения данных, представляя пользователю и программам удобный интерфейс для работы с данными.

##### Именование файлов:

Имя файла позволяет пользователю и операционной системе находить и обращаться к файлу. Оно состоит из двух частей: имя и расширение. Например, `document.txt`: до точки имя, после – расширение.

##### Структура:

Структура определяет, организацию данных внутри файла. Она определяется расширением файла (.txt, .exe, .o, .zip).

С точки зрения файловой системы, файл представляет набор блоков данных на диске. Система хранит метаданные (данные о размере, правах, дате модификации…) и указатели на блоки, которые физически хранят данные.

##### Типы данных:

- **Текстовые файлы** — содержат вполне читаемый текст (`.txt`, `.html`)
- **Бинарные файлы** — содержат данные в двоичном виде (`.jpg`, `.exe`)
- **Исполняемые файлы** — их можно запустить как программы (`.exe`, `.sh`)
- **Директории** — каталоги)
- **Специальные файлы** — в UNIX-подобных системах файл является очень распространенным видом абстракции. Практически всё в UNIX это файл. В том числе и устройства ввода/вывода. Они и считаются специальными. (`/dev/sda`)

##### Атрибуты файлов:

**Атрибуты файла** — это метаданные, которые предоставляют дополнительную информацию о файле и используются операционной системой для его управления.

- Имя
- Идентификатор (inode в Linux)
- Тип
- Расположение
- Размер
- Защита (информация о правах)
- Даты создания, последнего изменения, последнего доступа
- Владелец

##### Доступ к файлам:

Доступ регулируется системой, на основе прав доступа, которые хранятся в метаданных файла. Например в UNIX используется `rwx`. Каждому праву (read, write, execute) присваивается бит. Есть бит – есть право. Например, `110` --> `rw-`. `-` на месте `x` означает что права execute (запуск) нет. Права хранятся в виде: `rwxr-xr-x`. Таким образом они определяют доступные действия для владельца, группы и остальных.
Windows использует ACL — списки контроля доступа.

##### Операции с файлами:

- **Создание** — `touch файл`
- **Чтение содержимого** — `cat файл`
- **Запись (перезапись)** — `echo "текст" > файл`
- **Добавление в конец** — `echo "ещё текст" >> файл`
- **Удаление** — `rm файл`
- **Переименование** — `mv старое_имя новое_имя`
- **Копирование** — `cp исходный_файл копия`
- **Перемещение** — `mv файл путь/новое_место`
- **Изменение прав доступа** — `chmod 755 файл`

#### 59. Понятие каталога. Иерархические каталоговые системы. Операции с каталогами.

**Каталог** — это структура данных в файловой системе операционной системы, которая содержит ссылки на файлы и другие каталоги

##### Иерархические каталоговые системы:

Иерархические каталоговые системы организуют каталоги и файлы в древовидную структуру. Такая структура начинается с корневого каталога (в UNIX это `/`, в Windows – `C:\` (или другая буква)). 

**Абсолютный путь** — полный путь от корневого каталога, например, `/home/user/documents` или `C:\Users\Имя\Documents`.

**Относительный путь** — путь относительно текущего каталога, например, `documents` из `/home/user`.

##### Операции над каталогами:

- Создание — `mkdir`
- Удаление — `rmdir`
- Переименование — `mv`
- Навигация — `cd`
- Просмотр содержимого — `ls`
- Установка прав доступа — `chmod`
- Копирование и перемещение  — `cp`

#### 60. Задачи ОС по управлению файлами и устройствами.



#### 61. Структура файловой системы. Примеры ФС. Реализация файлов и каталогов (папок). Распределенная файловая система.