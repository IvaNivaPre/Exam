#### 28. Определение операционной системы (ОС). Место ОС в программном обеспечении компьютеров, компьютерных систем и сетей. Тенденции и перспективы развития операционных систем и сред.

**Операционная система** — это набор программ, который управляет аппаратными средствами компьютера и предоставляет среду для выполнения программ. ОС служит мостом между пользователем и компьютером, обеспечивая ресурсы для программ, управление файлами, памятью, процессами и многозадачностью.

##### Место ОС

В обеспечении компьютеров ОС играет важную роль, ведь она предоставляет интерфейс для взаимодействия пользователя, обеспечивает эффективное взаимодействие аппаратных частей компьютера и многое другое.

В компьютерных системах ОС обеспечивает эффективное взаимодействие узлов системы и централизованное управление.

ОС также часто используются в компьютерных сетях. Примером могут послужить ОС маршрутизаторов, коммутаторов и других сетевых устройств. Или например веб-хостинги. На их серверах стоят ОС, которые позволяют эффективно отвечать на запросы клиентов. В конце концов ОС обычных компьютеров участвует в сетевом соединении, обрабатывает пакеты, управляет сетевыми интерфейсами и многое другое.

##### Тенденции и перспективы

Направлений для развития ОС можно увидеть бесконечное множество. В последние годы сильно развиваются ОС мобильных устройств и встраиваемых устройств (устройства умного дома). Перспективным является направление разработки ОС, у которых в приоритете находится безопасность. ОС для квантовых компьютеров. Интеграция ИИ в ОС.

#### 29. Назначение, состав и функции ОС. Понятие компьютерных ресурсов.

##### Основные назначения ОС:
- Управление аппаратными компонентами и из взаимодействием. Распределение этих ресурсов между пользователями и процессами.
- Абстракция. Предоставление удобного интерфейса для взаимодействия с компьютером для пользователя. Сюда же можно отнести предоставление удобных функций для разработчиков ПО.
- Обеспечение безопасности и сохранности данных.
- Обеспечение связи между компьютерами в сети.
- Планирование задач, многозадачность...

##### Состав ОС: (по Васильеву)
- Текстовый пользовательский интерфейс
- GUI
- Программные библиотеки
- Утилиты
- Пользовательские программы

##### Функции ОС:
- Выполнение программ.
- Управление файловой системой.
- Управление устройствами ввода/вывода.

##### Понятие компьютерных ресурсов

**Ресурсы** — средства, имеющиеся в наличии, но к которым обращаются лишь при необходимости.

Существует много видов компьютерных ресурсов: аппаратные, файловые, программные (совокупность установленных программ), ресурс памяти (как постоянной, так и виртуальной) и многие другие.

Например к аппаратным ресурсам относятся: CPU, RAM, HDD/SSD, сетевые интерфейсы, устройства ввода/вывода.

#### 30. Концепция многоуровневого виртуального компьютера. Операционные оболочки и среды.

**Многоуровневый виртуальный компьютер** — это система, где физический компьютер может запускать несколько виртуальных машин, а внутри каждой из них можно создать еще одну виртуальную машину. Это создает многоуровневую структуру, где каждый уровень работает независимо, как отдельный компьютер. Используются в областях тестирования, кибербезопасности.

**Операционная оболочка** — это программа, предоставляющая интерфейс для взаимодействия пользователя с функциями операционной системы. Это может быть как командная строка, так и графический интерфейс.

#### 31. Архитектуры операционных систем.

| Тип архитектуры | Краткое описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Монолитное ядро | Все основные функции ОС встроены прямо в ядро. Обладает высокой скоростью, но слабой отказоустойчивостью. Представителями являются большинство UNIX-систем. При обращении к ядру происходит смена контекста (user mode -> kernel mode), выполнение запроса и возвращение обратно к программе (kernel -> user).                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Микроядро       | Ядро содержит только самые базовые функции (прерывания, процессы, планирование, межпроцессорное взаимодействие (IPC — Inter Process Communications), память). Остальное вынесено в отдельные процессы в пространстве пользователя. Такая система медленнее из-за постоянных переключений контекста (world switch). Но в то же время она надёжнее. Также такую систему проще расширять. Самыми яркими представителями являются MINIX и Mach (ядро Mac OS X). При обращении к ядру, происходит смена контекста (user -> kernel), микроядро выполняет переход к службе, находящейся в пространстве пользователя (kernel -> user), запрос выполняется и управление снова передаётся микроядру (user -> kernel) и наконец происходит возвращение к вызвавшему процессу (kernel -> user). |
| Гибридное ядро  | Модифицированные микроядра, которые позволяют запускать "несущественные" части в пространстве пользователя. Представителями являются NT Kernel, BSD-основанные.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Модульное ядро  | Модульные ядра, в отличие от «классических» монолитных ядер, не требуют полной перекомпиляции ядра, если меняется оборудование компьютера. Вместо этого, они позволяют загружать нужные модули (например, драйвера) для работы с новым аппаратным обеспечением без необходимости переписывать всё ядро.                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Наноядро        | Крайне упрощенное и минималистичное ядро выполняет лишь обработку аппаратных прерываний. После этого оно посылает информацию о результатах обработки вышележащему ПО.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Экзоядро        | Предоставляет лишь функции для взаимодействия между процессами, безопасного выделения и освобождения ресурсов.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
Режим ядра (kernel mode) часто называют *супервизором*.

#### 32. Поколения операционных систем. Классификация ОС. Интерфейсы операционных систем. Эволюция ОС. Эффективность ОС.

##### Поколения ОС:

- **Первое поколение (1945-1955):** На заре компьютерной эры каждым компьютером занималась своя команда инженеров. Все команды писались на машинном языке или даже строились электрическими схемами. Ничего даже близко похожего на ОС тогда не существовало. Да и не особо нужно было, ведь в основном компьютеры использовались для уточнения каких-то табличных значений (по типу синусов).
- **Второе поколение (1955-1965):** После применения транзисторов для построения компьютеров, появилось чёткое разделение между программистами и обслуживающим компьютер персоналом. Программист писал программу и переносил её на перфокарты, затем специальное устройство считывало программу и заносило всё на магнитную ленту. Эта лента вставлялась в компьютер и запускалась специальная программа (прообраз ОС). Она считывала задания с ленты и запускала его, записывая выходные данные на другую ленту. После работы вторая лента относилась на компьютер поменьше, который печатал информацию. После этого загружалась следующее задание.
- **Третье поколение (1965-1985):** К этому времени закрепились два типа компьютеров: большие и мощные (для научных работ и сложных вычислений) с пословной обработкой данных и небольшие, послабее (для повседневных задач или распечатки данных с больших компьютеров) с посимвольной обработкой. IBM хотела сделать такие типы совместимыми, чтобы одна программа могла работать на двух типах. Было разработано семейство машин IBM/360. У них была собственная ОС. Она обладала многозадачностью. Для этого память разбивалась на несколько разделов, в каждом из которых выполнялось своё задание. Также появилась возможность подкачки данных (spooling), когда раздел освобождался, ОС загружала новое задание с диска. Также в то время начала развиваться идея разделения времени, когда у каждого пользователя есть свой терминал для работы с машиной. Впоследствии была разработана система MULTCS а затем и UNIX.
- **Четвёртое поколение (1980-2025):** Происходило развитие микрокомпьютерных ОС. Компании IBM была нужна ОС для их нового IBM PC. Они обратились к Биллу Гейтсу, который выкупил у местного производителя компьютеров DOS (Disk Operating System) и с небольшими доработками отдал её IBM. Позже она была доработана до MS-DOS и быстро обрела доминирующее положение на рынке IBM PC. Далее начали появляться первые GUI. Изначально Windows был простой графической оболочкой, работающей поверх MS-DOS. Затем, в 1995 году, Windows отделилась как Windows 95 и впоследствии Windows 98. Это были системы, работающие на 16-разрядных процессорах. Позже вышла Windows NT для 32-разрядных систем. Параллельно ОС от Microsoft, развивались и другие системы. Для UNIX подобных систем была разработана X Window System, для графического интерфейса. Для этой системы можно было установить пользовательский интерфейс: Gnome/KDE. Также шло развитие сетевых, распределённых и мобильных ОС.

##### Классификация ОС:

- **ОС мейнфреймов**: отличаются огромными объёмами ввода/вывода данных. В основном ориентируются на одновременное выполнение огромного количества вычислений.
- **ОС серверов**: ориентируются на большое количество пользователей на одной машине.
- **Многопроцессорные ОС**: обеспечивают соединение множества центральных процессоров в единую систему для более эффективной работы.
- **ОС персональных компьютеров**: многозадачность.
- **ОС КПК.**
- **Встроенные ОС**.
- **ОС сенсорных узлов**: например системы видеонаблюдения.
- ОС реального времени: таким системам важно выполнить задачу в чётко заданное время. Бывают системы жёсткого и мягкого времени (строгие и не такие строгие). Например автопилот в самолёте или компьютер АЭС.

##### Интерфейсы взаимодействия ОС:

**Интерфейсы** — способы взаимодействия пользователя или приложений с ОС.

- **CLI (Command Line Interface)** — командная строка.
- **GUI (Graphical User Interface)** — графический интерфейс.
- **API (Application Programming Interface)** — набор функций для программного взаимодействия.
- **Системные вызовы (System Calls)** — низкоуровневый интерфейс программ к ядру ОС.

##### Эволюция ОС:

1) Переход от пакетной обработки к мультизадачности.
2) Появление многопользовательских систем.
3) Развитие GUI.
4) Расширение сетевых возможностей.
5) Развитие виртуализации и облачных технологий.
6) Развитие мобильных и встроенных ОС.

Эффективность ОС оценивается по **производительности**, **надёжности**, **устойчивости**, **безопасности**, **удобству использования**.

#### 33. Однопрограммные, многопрограммные, многопользовательские и многопроцессорные операционные системы и среды. Примеры распространенных ОС.

##### Однопрограммные ОС:

В каждый момент времени в памяти находится только одна программа, которая полностью задействует ресурсы процессора. Такой подход использовался в начале развития ОС. Пример: ранние версии MS-DOS.

##### Многопрограммные ОС:

В памяти находится сразу несколько программ и процессор может переключаться между ними. Такой подход эффективнее и используется сегодня во многих системах. Примеры: UNIX, Windows.

##### Многопользовательские ОС:

Несколько пользователей могут одновременно работать на одной машине. ОС будет распределять её ресурсы между ними. Примеры UNIX, Windows Server.

##### Многопроцессорные ОС:

Поддержка работы систем с несколькими процессорами для одновременного выполнения задач. Примеры Windows, Linux.

##### Среды:

**Среды ОС** — набор условий и инструментов, которые предоставляет операционная система для работы пользователя или программы. Среда это окружение, в котором загружается программа.

Различают два пространства (среды):

**Прикладная среда** (User space) — набор библиотек и сервисов для запуска приложений. Например Windows API или POSIX для UNIX систем.

**Системная среда** (Kernel) — переменные окружения, доступ к файловой системе и т.д.

![[Linux structure.png]]

##### Распространённые ОС:
- Windows
- Linux
- macOS
- Android
- iOS
- FreeBSD (многопользовательская)

#### 34. Прикладные операционные среды. Совместимость операционных систем. Виды совместимости. Языковая и двоичная совместимость.

В прикладных средах (User space) работают системы, которые не находятся в ядре по различным причинам.

##### Совместимость:
Можно придумать много разных примеров:
- **Файловая** — файлы с одной системы (NTFS от Windows) могут запускаться на другой (например на Linux). Это обеспечивается драйверами и виртуальными файловыми системами.
- **Прикладная** — возможность запускать приложения на разных системах. К примеру на Linux можно запускать приложения с Windows через WineHQ.
- **Стандарты POSIX (Portable Operating System Interface)** — чтобы системы были совместимыми (можно было переносить прикладные программы) был разработан стандарт POSIX. Он определял интерфейс ОС. Например он определяет набор стандартных системных утилит (cp, echo, cat…) для каждой совместимой системы.

**Языковая совместимость** — код нужно заново компилировать под каждую ОС.

**Двоичная совместимость** — совместимость на уровне готовых программных файлов. Код можно сразу запускать на другой системе.

#### 35. Эмуляция. Виртуальные машины и операционные среды.

**Эмуляция** — процесс, при котором одна система имитирует работу другой. Программа создаёт программную копию имитируемой аппаратной части. Например эмуляторы ARM-архитектуры. Wine имитирует Windows API для запуска приложений на Linux. Эмуляторы консолей на ПК.

**Виртуальная машина** — полная имитация одного компьютера внутри другого. Это работает с помощью технологии [виртуализации](Виртуализация.md).

**Операционные среды** — это окружение для приложений, которое эмулирует функции другой операционной системы без запуска отдельной ОС. Операционные среды просто реализуют API, не эмулируя работу железа какого-то устройства.

#### 36. Загрузка операционных систем (на примереe Windows, Linux). Этапы процесса загрузки. Работа загрузчика. Опции загрузочного меню. Выбор аппаратного профиля. Загрузка и инициализация ядра. Загрузка драйверов и сервисов. Регистрация пользователя.

##### Этапы загрузки Windows:
1) BIOS/UEFI выполняет POST (Power-On Self-Test), проверяя работоспособность устройств. Затем система идентифицирует допустимый системный диск и читает [^1]MBR (Master Boot Record) или GPT (GUID Partition Table) в зависимости от конфигурации. Это запускает Windows Boot Manager (WBM).
2) WBM может отображать меню загрузки, если на компьютере установлено несколько ОС. Пользователь может выбрать одну из них и например войти в безопасный режим.
3) Далее система использует технологию Plug-and-Play для автоматического обнаружения и конфигурации оборудования. Она сканирует слоты расширения (PCI), для идентификации подключенных устройств. В дальнейшем Windows будет загружать драйвера для этих устройств.
4) После запуска Boot Manager загружается Windows Loader, который загружает ядро (инициализирует). Оно инициализирует критические компоненты, такие как управление памятью и подготавливает систему к более высокоуровневым операциям.
5) После инициализации ядра Windows загружает драйверы устройств и системные службы (API, предоставляющий доступ прикладным программам, к аппаратным ресурсам системы).
6) Затем инициализируется GUI и отображает экран входа. Пользователь вводит имя пользователя и пароль, которые аутентифицируются через Security Accounts Manager (SAM). После успешной аутентификации загружается рабочий стол пользователя.

[^1]: MBR и GPT это разные схемы разделов для дисков. MBR это старая схема, ограничивающая диск до 2 ТБ и поддерживая 4 основных раздела. GPT – таблица разделов, работающая с глобально уникальными идентификаторами GUID (Globally Unique Identifier). Это современная схема, поддерживая огромные диски и до 128 разделов.

##### Этапы загрузки Linux:
1) BIOS/UEFI выполняет POST и загружает MBR с загрузочного диска. В этой записи содержится программа. которая запускает вторичный загрузчик, например GRUB (GRand Unified Bootloader) (их существует много), который читает конфигурационные файлы, чтобы узнать доступные ОС и т.п.
2) GRUB отображает различные варианты загрузки, позволяющие пользователю выбрать различные режимы восстановления и так далее.
3) Запускается начальный код ядра. Читаются конфигурационные файлы, для определения устройств ввода-вывода, и добавляются в таблицу устройств.
4) Далее GRUB загружает само ядро Linux и начальный RAM-диск (специальная файловая система для загрузки ОС) в память, передавая управление ядру. Его начальный код, написанный на ассемблере, определяет тип процессора, вычисляет доступную RAM, отключает прерывания, активирует MMU и вызывает процедуру, написанную на C, для продолжения запуска ядра.
5) После инициализации ядра система начинает конфигурацию оборудования. Загружаются драйверы. Ядро запускает процесс 0. который продолжает инициализацию, включая настройку таймеров, монтирование корневой файловой системы, и создания процесса 1 (init) и процесса-демона страниц (процесс 2). init, в зависимости от флагов, запускает систему в однопользовательском или многопользовательском режиме, запуская скрипты инициализации.
6) Далее init запускает программу getty, которая настраивает свойства терминала и отображает приглашение для ввода. Когда пользователь вводит имя, getty выполняет /bin/login, который запрашивает пароль и сравнивает его с информацией из /etc/passwd.

До этапа загрузки ядра процессор работает в реальном режиме (16 бит), затем переключается в защищенный (32 или 64 бит).

#### 37. Инсталляция и конфигурирование многопрограммной многопользовательской ОС с графическим интерфейсом (на примере Windows,). Требования к аппаратным ресурсам. Подготовка процесса инсталляции. Конфигурирование разделов на жестком диске. Выбор файловой системы. Выбор варианта установки (локальная, сетевая). Инсталляция мультиоперационных систем.

##### Локальная установка Windows:

1) Проверить устройство на соответствие минимальным требованиям: процессор 1ГГц, 2 Гб (64-разрядная версия) или 1 Гб (32-разрядная) ОЗУ, 32 Гб дискового пространства.
2) Для установки необходимо создать загрузочный носитель. Оптимальным вариантом является флешка. Она должна быть не менее 8 Гб. Для создания такого носителя необходимо установить специальную программу Media Creation Tool и следовать инструкциям в ней.
3) В BIOS/UEFI нужно выбрать в качестве boot device это загрузочное устройство, и тогда ОС начнёт загружаться.

##### Локальная установка Linux:

1) Выбрать подходящий дистрибутив, в соответствии с конфигурацией компьютера. Загрузить ISO-образ с официального сайта.
2) Далее необходимо создать загрузочную флешку.  Для этого можно воспользоваться программой Rufus.
3) В BIOS/UEFI нужно выбрать в качестве boot device это загрузочное устройство, и тогда ОС начнёт загружаться.

##### Сетевая установка:

1) Необходимо настроить WDS на сервере. Он нужен чтобы клиенты обращались к нему и получали загрузочные образы.
2) Далее нужно настроить PXE, чтобы машина могла загружаться по сети. Компьютер запрашивает загрузочный образ у сервера, получает и начинает установку ОС.
Такой способ удобен для массовой установки в корпоративных средах.

##### Конфигурирование разделов:

**Windows:**
Во время установки можно создать разделы на жёстком диске. Для этого нужно выбрать пользовательский режим установки и создать новый раздел. Также это возможно сделать через консоль. Для этого нужно открыть её (Shift + F10) и ввести команду `diskpart`. Далее можно посмотреть список дисков (`list disk`), выбрать нужный (`select disk <номер_диска>`) и создать раздел (`create partition primary size=n`).

Linux:


##### Выбор файловой системы:

Windows 10 по умолчанию использует файловую систему NTFS, которая является хорошим выбором. Также Windows поддерживает FAT, но это немного устаревший формат, поэтому не рекомендуется форматировать диски под него.

##### Инсталляция мультиоперационных систем:

Для установки нескольких ОС (например двух) необходимо предварительно создать разделы диска под каждую ОС. Затем необходимо по очереди установить ОС. Если первая ОС не отображается, нужно использовать инструменты для восстановления загрузчика (Boot-Repair в Linux).

#### 38 - 39. Концепция процессов и потоков. Определение и модель процесса. Создание и завершение процессов. Иерархия процессов. Операции над процессами. Состояния процесса: выполнение, приостановка, возобновление. Блок управления процессами. Алгоритмы планирования.

**Процесс** — это экземпляр исполняемой программы (абстракция исполняемой программы), включающий текущие значения счетчика команд, регистров и переменных. Процесс состоит из нескольких частей: текстовый сегмент, в котором содержится исполняемый код программы, сегмент данных, в котором хранятся данные, необходимые для работы программы и сегмент стека (контекст), в котором хранится контекст вызова, например, переменные окружения и команду, с помощью которой была запущена программа (так она сможет понять, с какими аргументами её запустили).


Виртуальное адресное пространство процесса делится на User Space и Kernel Space. Первое используется, когда процесс работает в пользовательском режиме, а второй — в режиме ядра. В них хранятся данные для работы каждого режима.

Текстовый сегмент находится в самой нижней части пространства. За ним располагаются два сегмента данных: первый для инициализированных переменных, второй для неинициализированных. Ещё выше находится куча (Heap). Она используется для динамически выделяемых данных (размер или срок жизни которых нельзя предсказать на этапе компиляции (массивы, списки, хэш-таблицы)). В самом верху пространства пользователя находится стек, который хранит информацию о вызовах функций и системных вызовах. (Такая схема актуальна для 32-битных систем (у каждого процесса есть возможность обратиться только к $2^{32}$ адресам), у 64-битных систем адресное пространство может включать в себя до 128 Тб, т.к. для адресации используется всего лишь 48 бит)
![[Process scheme.png]]

**Потоки** — аналоги процессов, которые делят память внутри одного процесса. (дальше есть более подробная информация про них)

##### Состояния процесса:

У процесса может быть 3 основных состояния:
- **Выполнение** — процесс использует CPU.
- **Готовность** — процесс ждёт пока его выберет планировщик.
- **Блокировка** — процесс ожидает какого-то события, например, завершения операции ввода/вывода.

Также существует семиступенчатая модель:
- **Новый** — процесс только что создан.
- **Готов** — загружен в основную память, ждет свободного CPU.
- **Выполняется** — процесс использует CPU.
- **Заблокированный/ожидающий** — ожидает I/O, пользовательского ввода или критической секции.
- **Terminated/Completed** — убит или выполнен, ресурсы освобождены.
- **Приостановленный готовый** — готовый процесс, который выгружен на внешнее хранилище.
- **Приостановленный заблокированный** — заблокированный процесс, который выгружен на внешнее хранилище.

##### Создание процесса и завершение процесса


Создание процесса может произойти через:
- Инициализацию самой ОС (например init при старте системы).
- Создание процесса как дочернего от какого-то другого (fork).
- Создание процесса по запросу пользователя (например какая-нибудь команда в bash).
- Инициализацию пакетного задания. Это происходит в мейнфреймах и вычислительных центрах, где пользователи подготавливают задания, которые загружаются в файл и помещаются в очередь. ОС запускает процессы из этой очереди, таким образом инициатором создания является система, но по предварительной заявке пользователя.

Варианты завершения процесса:
- Нормальное завершение (добровольно) — вызов команды exit(0) (0 - код штатного завершения), процесс добровольно выходит, выгружая свои ресурсы.
- Выход при возникновении ошибки (добровольно) — процесс завешается с кодом ошибки.
- Возникновение критической ошибки (принудительно) — ОС принудительно завешает процесс из-за критической ошибки, например, сегфолта или деления на ноль.
- Завершение из другого процесса (принудительно) — внешний процесс завершает данный с помощью сигнала SIGKILL.

##### Системные вызовы для управления процессами:
- `pid=fork()` — создать дочерний процесс, идентичный родительскому.
- `pid=waitpid(pid, &statloc, opts)` — ждать завершения дочернего процесса.
- `s=execve(name, argv, envp)` — заменить образ памяти процесса.
- `exit(status)` — завершить выполнение процесса и вернуть статус.
- `s=sigaction(sig, &act, &oldact)` — определить действие, выполняемое при приходе сигнала.
- `s=kill(pid, sig)` — послать сигнал процессу.

fork() — системный вызов, который создаёт точную копию родительского процесса, включая адресное пространство. fork() возвращает значение, равное нулю, если выполняется в дочернем процессе и PID дочернего процесса, если в родительском.

После fork(), у родительского процесса обычно вызывается waitpid, который ждёт завершения дочернего процесса (если указать PID, то будет ждать определённого, если -1, то любого). Для дочернего процесса вызывается `execve`, который заменяет образ памяти (который наследовался от родителя) на программу, которую должен выполнять дочерний процесс.

Упрощенный пример оболочки:
```
while (TRUE) {
    /* бесконечный цикл */

    type_prompt();                   /* вывести приглашение к вводу */
    read_command(command, params);  /* прочитать с клавиатуры строку ввода */

    pid = fork();                   /* ответвить дочерний процесс */

    if (pid < 0) {
        printf("Создать процесс невозможно");  /* ошибка */
        continue;                              /* повторить цикл */
    }

    if (pid != 0) {
        waitpid(-1, &status, 0);   /* родительский процесс ждет дочерний процесс */
    } else {
        execve(command, params, 0);  /* дочерний процесс выполняет работу */
    }
}
```

##### Иерархия процессов:

Все процессы происходят от корневого процесса init. Они инициализируются путём вызова fork. Также могут быть осиротевшие процессы (если родительский процесс завершился), они становятся детьми init.

##### Блок управления процессами:

Процессы хранятся в таблице процессов. Каждая запись в ней называется PCB. Таблица страниц не может быть выгружена.

**PCB (Process Control Block)** — это структура данных (дескриптор процесса), которую операционная система использует для хранения информации о процессе.

PCB содержит данные и указатели на области:
- PID.
- Текущее состояние процесса (например, Ready, Running, Blocked).
- Счетчик команд (Program Counter), который указывает на следующую инструкцию для выполнения.
- Регистры процессора.
- Указатели на сегменты текста, данных и стека.
- Список открытых файлов и дескрипторов.
- Статус ввода-вывода.

##### Алгоритмы планирования
Алгоритмы [здесь](Планирование)

#### 40. Обработка прерываний.

**Прерывание** — это сигнал, который прерывает нормальный поток выполнения процессора, требуя немедленной обработки.

##### Классификация прерываний:

- **Внешние** (аппаратные) — возникают от внешних устройств: таймеры, устройства ввода/вывода. Называются асинхронными, ведь процессор не знает в какой момент они произойдут.
- **Внутренние** — вызываются самим процессором, например, при делении на ноль, обращении к недоступному адресу или переполнении стека. Называются синхронными так как они предсказуемо связаны с потоком выполнения программы. Если повторно выполнить программу, прерывание произойдёт в том же месте.
- **Программные** — инициализируются инструкциями. Например INT (ассемблер) (от interrupt) в x86 архитектуре процессоров. Команда буквально инициирует переход к обработчику прерываний с заданным номером. Номер обозначает к какому обработчику идёт обращение. 
- **Маскируемые** — некоторые прерывания могут быть отключены программно. Процессор будет их просто игнорировать.
- **Немаскируемые** — прерывания, которые нельзя отключить.


##### Механизм обработки прерываний:

1) **Обнаружение**. Процессор мониторит линии прерываний, чтобы обнаружить сигнал.
2) **Подтверждение**. При получении сигнала, процессор оповещает устройство, которое его вызвало, о начале обработки, чтобы оно прекратило посылать сигнал.
3) **Сохранение контекста**. Прерывание — это переключение контекста процессора, поэтому необходимо сохранить его текущее состояние, чтобы позже к нему вернуться.
4) **Переход к обработчику**. Находится нужный обработчик и осуществляется переход к нему.
5) **Выполнение**. Обработчик выполняет необходимые действия.
6) **Восстановление**. Восстанавливается сохранённое состояние процессора и возобновляется выполнение.

#### 41. Ядро операционной системы.

**Ядро операционной системы** — это центральный компонент, который управляет ресурсами компьютера и обеспечивает взаимодействие между аппаратным и программным обеспечением. Оно действует как низший уровень абстракции, позволяя приложениям получать доступ к необходимым ресурсам через межпроцессное взаимодействие и системные вызовы.

##### Основные функции ядра:

###### Управление процессами:

Ядро отвечает за создание, планирование и завершение процессов. Также ядро может управлять и потоками (если они реализованы на уровне ядра).

###### Управление памятью:

Ядро выделяет и освобождает память для процессов, управляет виртуальной памятью и обеспечивает изоляцию адресных пространств процессов.

###### Управление устройствами:

Через [драйверы](Драйверы)  ядро взаимодействует с аппаратными компонентами ввода/вывода, такими как клавиатуры, мониторы, сетевые карты и т.д.

###### Управление файловой системой:

Ядро предоставляет интерфейс для взаимодействия с файлами и каталогами, обеспечивая доступ к данным на различных носителях (HDD/SSD). Оно выполняет операции чтения, записи, удаления файлов.

###### Управление сетью:

Ядро реализует сетевые протоколы и обрабатывает пакеты.

###### Системные вызовы и безопасность:

Организация обращений к ядру через системные вызовы обеспечивает безопасность, предотвращая несанкционированный доступ к ресурсам и защищая само ядро от вмешательства приложений. Системные вызовы производятся при помощи прерываний.

#### 42. Потоки и их использование. Модель потока. Реализация потоков в пространстве пользователя. Реализация потоков в ядре. Смешанная реализация. Активация планировщика.

**Потоки** — это последовательные потоки выполнения задач внутри процесса, которые позволяют разделить процесс на независимые задачи. Они делят с процессом код, данные и ресурсы операционной системы, такие как открытые файлы, но имеют собственный стек, счетчик программы и набор регистров. Из-за общих данных поток создаётся гораздо быстрее чем процесс (не надо выделять память или создавать объёмные PCB).

##### Реализация потоков на уровне пользователя:

Потоки в пространстве пользователя (User-Level Threads, ULT) управляются библиотекой в пространстве пользователя, без вмешательства ядра.

**Преимущества:**
- Из-за того, что ядро не вмешивается (не происходит постоянного переключения контекстов), создание, уничтожение и переключение между потоками происходит очень быстро.
- Такие потоки могут работать в ОС, в которой потоки не поддерживаются. Также из этого следует, что программист может сам написать логику планирования потоков.

**Недостатки:**
- Если один поток вызывает блокирующий вызов, блокируется весь процесс.
- Так как ядро видит только один поток (ULT как бы находятся внутри KLT, а при такой реализации KLT один), ОС не может планировать их работу по отдельности и распределять по разным процессорам.

##### Реализация потоков на уровне ядра:

Потоки в ядре (Kernel-Level Threads, KLT) управляются операционной системой и являются частью ядра.

**Преимущества:**
- Потоки могут выполнятся параллельно, на разных процессорах.
- Если один поток делает блокирующий системный вызов, то остальные потоки продолжают работать.

**Недостатки:**
- Большие накладные расходы (переключение контекста), соответственно операции над ними производятся медленнее.
- Ядро может ограничивать допустимое количество потоков.

##### Смешанная реализация:

Смешанная реализация (Many-to-Many Model) сочетает пользовательские и ядерные потоки, обеспечивая гибкость и производительность. Библиотека в пространстве пользователя управляет пользовательскими потоками, а ядро управляет потоками ядра, обеспечивая координацию между уровнями.

Сочетает преимущества двух реализаций, но требуют сложной координации между пользовательским и ядерным уровнем.

##### Модель потока:

Модель определяет, как потоки взаимодействуют с процессом и ОС. В любой модели KLT содержит в себе ULT (например как процессы содержат потоки). Это означает что ОС может взаимодействовать только с наружной частью (KLT).

- **Многие-к-одному** — управление потоками осуществляется библиотекой в пространстве пользователя, что делает создание и переключение потоков быстрым (из-за отсутствия переключения контекста), но если один поток выполнит блокирующий вызов, заблокируется весь процесс. Т.е. это реализация потоков на уровне пользователя.
- **Один-к-одному** — каждый пользовательский поток имеет поток ядра. Можно сказать что это просто реализация потоков на уровне ядра.
- **Многие-ко-многим** — гибридная модель, где многие пользовательские потоки отображаются на равное или меньшее количество потоков ядра. Это означает, что каждый поток ядра как бы содержит несколько потоков пользователя. Если один из пользовательских потоков выполняет блокирующий вызов, блокируется только поток уровня ядра, в котором он хранится (правильнее "которому соответствует"). Т.е. это смешанная реализация.

##### Активация планировщика:

**Scheduler Activations** — это механизм, при котором ядро и пользовательская библиотека потоков сотрудничают, чтобы обеспечить быстроту ULT и параллельность KLT.

При таком подходе применяются легковесные процессы (Lightweight Processes, LWP) (LWP это абстракция, выполняющая работу). В современных ОС можно сказать KLT = LWP. Предположим что у нас есть 20 ULT и 4 процессора, между которыми их нужно распределить.
Выделяется 4 LWP с помощью scheduler activations. LWP будет сообщать библиотеке потоков уровня пользователя о различных событиях. Предположим что на процессоре №2 ULP#4 заблокировался. Вместо того, чтобы блокировать весь LWP (который содержит и другие ULP), посылается upcall — сообщение библиотеке о том, что один из её потоков заблокировался и что нужно выбрать новый. Библиотека должна решить какой поток ставить вместо заблокированного. Таким образом остаются положительные стороны двух реализаций потоков, но для этого нужно реализовать крайне сложную систему как со стороны ядра ОС, так и со стороны библиотеки

#### 43. Всплывающие потоки (нити). Возможности создания многопоточных программ. Концепция волокон.

**Всплывающий поток (pop-up thread)** — это поток, который автоматически создаётся системой при поступлении входящего сообщения (например, сетевого запроса), исключительно для обработки этого сообщения.

Основное преимущество данных потоков заключается в быстроте. Они создаются с чистого листа, без необходимости восстанавливать регистры, стек и другие данные. Из-за этого их используют в распределённых системах и серверах.  (они минимизируют задержку между поступлением сообщения и началом его обработки, обеспечивая быстрый отклик).

##### Возможности создания многопоточных программ:

Создание многопоточных программ возможно из-за широкого набора инструментов, предоставляемых различными языками программирования и операционными системами. Они позволяют создавать мьютексы, семафоры и другие структуры для управления общим доступом к ресурсам.

##### Концепция волокон:

**Волокна (fibers)** — это легковесные потоки, управляемые приложением, а не операционной системой. Это ULT.

#### 44. Взаимодействие и синхронизация процессов и потоков. Параллельные асинхронные процессы и межпроцессное взаимодействие. Уровни параллелизма: задания, задачи, процессы, потоки Состояния состязания.

**Процессы** во время своего выполнения могут взаимодействовать между собой через механизмы межпроцессорного взаимодействия (IPC).
**Потоки** также взаимодействуют между собой, только гораздо проще, ведь у них общее адресное пространство.

Но тут может возникнуть проблема синхронизации. Когда несколько процессов или потоков допускаются к общим ресурсам (например, разделяемой памяти), может возникнуть состояние состязания (race condition), если порядок доступа не контролируется.

**Состояния состязания (Race Conditions)** — состояние, когда два или более процесса или потока допускаются к общему ресурсу (например, разделяемой памяти) одновременно, и результат зависит от порядка их выполнения. Оно может привести к неопределённому поведению в программе.

**Параллельные процессы** — процессы, которые выполняются одновременно, что достигается за счет распределения задач по нескольким процессорам или ядрам.

**Асинхронные процессы** — процессы, которые не ждут завершения друг друга, а продолжают выполнение независимо. Они часто используется для задач с вводом-выводом или с удалёнными запросами.

**Межпроцессное взаимодействие (IPC)** — это обмен данными между процессами, которые могут работать на одном компьютере или в сети.

**Основные механизмы:**
- *Сокеты* — запись и чтение общего файла или сетевого соединения.
- *Каналы (pipe)* — односторонний поток между процессами.
- *Очереди сообщений* — процесс может поместить в очередь сообщение, а другой может его оттуда прочитать посредством системных вызовов, при условии того, что процессы используют одинаковый ключ доступа.
- *Разделяемая память* — область, общая для нескольких процессов.
- *Семафоры, мьютексы, мониторы* — про них написано дальше.

##### Уровни параллелизма:

**Задания (Jobs)** — наивысший уровень параллелизма. Это крупная единица работы, которая может быть разделена на задачи. Например, в пакетных системах задание может включать несколько программ, выполняемых последовательно или параллельно

**Задачи (Tasks)** — часть задания, которая может быть выполнена независимо. Они распределяются по процессам и потокам.

**Процессы (Processes)** — независимые единицы выполнения с собственным адресным пространством. Они выполняются на разных процессорах, таким образом достигается параллельная работа.

**Потоки (Threads)** — легковесные процессы, делящие адресное пространство в пределах одного процесса между собой. Потоки также могут выполняться на нескольких процессах.

#### 45. Взаимоисключения и критические участки. Примитивы и алгоритмы взаимоисключения.

**Взаимоисключение (mutual exclusion)** — это концепция, которая обеспечивает, что только один процесс или поток может получить доступ к общему ресурсу в один момент времени. Это необходимо для предотвращения состояний состязания (race conditions).

**Критические участки (critical sections)** — это части программного кода, где происходит доступ к общим ресурсам. Одновременный доступ к этим ресурсам без контроля может привести к состоянию состязания, где результат зависит от порядка выполнения операций. Например, если два процесса пытаются увеличить общий счетчик, один может перезаписать изменения другого, что приведет к потере данных.

Для предотвращения таких ситуаций необходимо обеспечить, чтобы только один процесс или поток мог находиться в критической секции в один момент времени. Это достигается с помощью механизмов взаимоисключения, которые гарантируют, что доступ к ресурсам строго упорядочен.

**Примитивы** — это базовые инструменты, используемые для реализации взаимоисключения. Они предоставляют низкоуровневые механизмы для управления доступом к критическим секциям. К ним относятся Семафоры, мьютексы, мониторы и аппаратные примитивы (Test-and-Set).

**Алгоритмы** — это методы, которые используют примитивы или другие техники для обеспечения того, чтобы только один процесс или поток мог войти в критическую секцию в один момент времени.

**Атомарные инструкции (atomic instructions)** — операции, которые выполняются полностью или не выполняются вовсе, без прерываний другими потоками. Если они начали своё выполнение, то они не могут быть прерваны.

- **Алгоритм Петерсона** — обеспечивает программное решение проблемы для *двух процессов*. Алгоритм использует две общие переменные, где каждый процесс устанавливает свой флаг, когда хочет зайти в критическую область, и переменную turn, которая указывает, чья очередь входить. У такого алгоритма есть недостатки: он работает только для двух конкурирующих потоков (процессов) и в нём присутствует активное ожидание (пустой цикл, который просто так нагружает процессор). Современные процессоры могут изменять последовательность доступа к памяти по своему усмотрению (для более эффективной работы), а для корректной работы алгоритма крайне важен порядок выполнения инструкций, поэтому такой подход сегодня и не используется (библиотека `atomic` из примера как раз исправляет эту проблему).
```
#include <atomic>

std::atomic<bool> flag[2];
std::atomic<int> turn; // доступ должен быть атомарным

void enter_critical(int id) {
    int other = 1 - id;
    flag[id] = true;
    turn = other;
    while (flag[other] && turn == other); // ожидание
}

void exit_critical(int id) {
    flag[id] = false;
}
```

- **Алгоритмы на основе токенов (Token-based Algorithms)** — только процесс, владеющий токеном, может войти в критическую секцию. Принцип, похожий на [[Token Ring]].
- **Алгоритмы на основе кворумов (Quorum-based Algorithms)** — процесс должен получить разрешение от большинства (кворума) других процессов, чтобы войти в критическую секцию.

#### 46. Семафоры, мониторы, передача сообщений. Проблемы межпроцессного взаимодействия.

**Спин блокировки (spinlock)** — механизм, который постоянно проверяет, свободна ли блокировка, не покидая CPU. Spinlock это механизм, который служит основой для более сложных структур (для [семафоров](Семафоры), [мьютексов](Мьютексы), [мониторов](мониторы)).

```
struct spinlock_t {
    int acquired = 0; // какой-то объект, у которого есть атрибут acquired (занят)
};

// Это демонстрационная реализация аппаратной атомарной функции
// она должна выполняться как одна неделимая инструкция
int TestAndSet(int* val) {
    int oldValue = *val;
    *val = 1;
    return oldValue;
}

void Lock(spinlock_t* s) {
    while (TestAndSet(&s->acquired)); // активное ожидание
}

void Unlock(spinlock_t* s) {
    s->acquired = 0;
}
```

##### Проблемы межпроцессного взаимодействия:

- **Состояния состязания (Race Conditions)** — возникают, когда несколько процессов или потоков одновременно обращаются к общим ресурсам (например, разделяемой памяти) без надлежащей синхронизации.
- **Блокировки (Deadlocks)** — возникает, когда два или более процесса блокируют друг друга, ожидая освобождения ресурсов.
- Накладные расходы — синхронизация IPC требует дополнительных вычислительных ресурсов, таких как системные вызовы для управления семафорами.
#### 47. Ресурсы и их захват процессами. Выгружаемые и невыгружаемые ресурсы. Примеры тупиков при распределении ресурсов. Обнаружение и предотвращение тупиков. Алгоритмы разрешения тупиков. Восстановление после тупиков.

Deadlock это всё-таки "взаимоблокировка" а не "тупик", поэтому я буду использовать этот термин.

**Ресурс** — это объект, который необходим процессу для выполнения.
Процессы запрашивают ресурсы через системные вызовы, и если ресурс доступен, он выделяется. Если ресурс занят, процесс может ждать, что иногда приводит к взаимоблокировкам, особенно если процесс уже удерживает другие ресурсы.

##### Выгружаемые и невыгружаемые ресурсы:

**Выгружаемые ресурсы** — ресурсы, состояние которых можно легко сохранить и восстановить, что позволяет операционной системе отобрать их у процесса. Примером может служить память или CPU.

**Невыгружаемые ресурсы** — те, которые нельзя отобрать у его текущего владельца, не вызвав потенциально сбоя в вычислениях. Например, принтеры, открытый файл.

##### Примеры взаимоблокировок:

Предположим что каждый из двух процессов захотел записать отсканированный документ на Blu-ray диск. Процесс `A` запрашивает разрешение на использование сканера и получает его. Процесс `B` запрограммирован по-другому: он сначала запрашивает разрешение на использование пишущего Blu-ray привода и получает его. Затем процесс `A` запрашивает разрешение на использование привода, но получает отказ, ведь он занят другим процессом. В свою очередь `B` запрашивает доступ к сканеру, на что получает отказ, ведь он держится процессом `A`. В этот момент процессы оказываются заблокированными навсегда. Такая ситуация называется взаимоблокировкой.

##### Обнаружение взаимоблокировок:

Обнаружение взаимоблокировок включает проверку графа выделения ресурсов на наличие циклов. Если он обнаружен, значит в системе взаимоблокировка.

![[Resource dependencies graph.png]]


##### Условия возникновения взаимоблокировок:

- *Условие взаимного исключения.* Каждый ресурс либо выделен в данный момент только одному процессу, либо доступен. (Процесс `A` держит принтер и процесс `B` не может захватить его. Если бы ресурсы были разделимыми, то процесс `B` мог бы захватить принтер и потенциальной блокировки можно было бы избежать. С принтером такое вряд ли выйдет сделать, но так можно использовать другие ресурсы, например делая их доступными только для чтения.)
- *Условие удержания и ожидания.* Процессы, удерживающие в данный момент ранее выделенные им ресурсы, могут запрашивать новые ресурсы.
- *Условие невыгружаемости.* Ранее выделенные ресурсы не могут быть принудительно отобраны у процесса. Они должны быть явным образом высвобождены тем процессом, который их удерживает.
- *Условие циклического ожидания.* Должна существовать кольцевая последовательность из двух и более процессов, каждый из которых ожидает высвобождения ресурса, удерживаемого следующим членом последовательности.

Есть два подхода к взаимоблокировкам: предотвращение и избегание.

##### Предотвращение взаимоблокировок:

Если "разрушить" хотя бы одно из условий возникновений взаимоблокировок, то она будет невозможна.

- **Атака условия взаимного исключения**. Цель: сделать ресурсы одновременно доступными для нескольких процессов. Это достигается за счёт доступа только для чтения. Так процессы не смогут друг другу помешать. Однако так можно сделать не со всеми ресурсами (например устройства вывода).
- **Атака на условие удержания и ожидания**. Цель: запретить удерживать один ресурс и при этом ждать другой. Процессы должны запрашивать все ресурсы до начала выполнения. Запросить ресурсы можно только в случает если нет уже захваченных ресурсов, иначе нужно отпустить и попробовать заново. Это сильно снижает эффективность.
- **Атака на условие удержания и ожидания**. Цель: сделать ресурсы прерываемыми, чтобы их можно было отобрать. Но не все ресурсы можно выгрузить.
- **Атака на условие циклического ожидания**. Цель: не дать возникнуть циклу в графе ожиданий. Ресурсам назначаются номера. Процессы могут запрашивать номера только в возрастающем порядке. Это требует дополнительного проектирования и более сложной логики приложения.

##### Алгоритмы избегания взаимоблокировок:

- **Страусиный алгоритм** (не совсем алгоритм, но про это лучше упомянуть) — самый простой способ это игнорирование проблемы. Такой способ подходит не для всех систем (если нужна абсолютная стабильность, то этот способ не подойдёт). Он используется в большинстве десктопных ОС. Постоянный мониторинг системы на наличие взаимоблокировок и их устранение это требовательные процессы. В среднем система переходит в состояние deadlock раз в 2 года. При таком раскладе будет проще перезагрузить компьютер один раз, чем два года терпеть лишнюю трату вычислительных ресурсов.
- **Траектории ресурса** — графическое представление, показывающее возможные состояния системы при последовательном выделении ресурсов. Есть небезопасные зоны, в которых может возникнуть взаимоблокировка, и безопасные зоны, в которых её можно избежать. Идея в том, чтобы не заходить в эти зоны на графике.
- **Алгоритм банкира** — у каждого процесса есть переменные: `m` = максимальное количество ресурса, которое он может запросить; `c` = сколько выделено ресурсов процессу сейчас. "Банкир" может удовлетворить запрос процесса только в случае если `m` + `a` <= доступного количества ресурса всего. В случае если нужно регулировать ситуацию со многими ресурсами, то алгоритм остаётся тот же, просто информация хранится в виде матриц.

##### Восстановление после тупиков:

- Восстановление за счет приоритетного овладения ресурсом. ОС может просто отобрать ресурс у одного процесса и отдать другому.
- Восстановление путем отката. Отката до контрольной точки, в которой не было deadlock.
- Восстановление путем уничтожения процессов. Нет процессов — нет проблем).

#### 48. Моделирование на языках высокого уровня вычислительного процесса многопрограммных операционных систем с детализацией уровней задач, процессов, потоков и тупиков.

Не нужно

#### 49. Мультипрограммирование. Аппаратно-программные средства поддержки мультипрограммирования.

**Мультипрограммирование** — это способ организации вычислений, при котором в оперативной памяти одновременно находятся несколько программ (процессов), и процессор переключается между ними, чтобы обеспечить эффективное использование ресурсов. Например, когда один процесс ожидает ввода/вывода, процессор переключается на другой процесс.

##### Аппаратные средства поддержки:

- **Изоляция памяти**. Из-за механизма виртуальной памяти каждый процесс обладает собственным адресным пространством, и другие процессы не могут повредить его при переключении. Виртуальная память поддерживается MMU.
- **Прерывания**. При переключении между процессами происходит прерывание, которое аппаратно поддерживается процессорами.
- **Ядра**. Большое количество ядер на современных процессорах существуют как раз для поддержки мультипрограммирования.

##### Программные средства поддержки:

- **Планировщик**. Обеспечивает эффективное использование процессоров.
- **Таблицы процессов**.
- **Механизмы синхронизации**. Нужны чтобы не возникало конфликтов между процессами.
- **Буферизация ввода/вывода**.

#### 50. Иерархическая организация памяти. Функции ОС по управлению памятью. Задачи распределения памяти. Алгоритмы распределения памяти. Распределение фиксированными и динамическими разделами.

##### Иерархическая организация памяти:

Память организована иерархически по скорости и объёму:
- **Регистры процессора** — самый быстрый и небольшой по объёму тип памяти. Предназначены для хранения временных данных, нужных процессору для вычислений.
- **Кеш-память** (L1 L2, L3). Больше и медленнее регистров. Используется для ускорения доступа к ОЗУ.
- **ОЗУ** — основная память компьютера. В ней хранятся данные запущенных программ.
- **Диски** — самая медленная и объёмная память. Используется для долгосрочного хранения данных.

##### Функции ОС по управлению памятью:

- **Выделение и освобождения памяти**. ОС выделяет память процессам при их запуске и освобождает ее после завершения работы.
- **Защита памяти**. Обеспечивает изоляцию адресного пространства каждого процесса.
- **Управление виртуальной памятью**. Это позволяет эффективно использовать RAM.
- **Минимизация фрагментации**.

##### Задачи распределения памяти.

По сути функции ОС выполняют задачи.

- **Эффективное использование памяти**. Максимально использовать доступное пространство.
- **Поддержка многозадачности**. Обеспечивать одновременный доступ к памяти для нескольких процессов.
- **Защита данных**.

##### Алгоритмы распределения памяти:

- **First Fit (Первый подходящий)**. Выделяет первый свободный блок памяти, который достаточно велик для запроса. Простой, но может привести к фрагментации.
- **Best Fit (Лучший подходящий)**. Выделяет самый маленький свободный блок, который подходит для запроса. Минимизирует отходы, но требует больше времени на поиск.
- **Worst Fit (Худший подходящий)**. Выделяет самый большой свободный блок. Может оставлять большие свободные области, но помогает избежать фрагментации в долгосрочной перспективе.
- **Next Fit (Следующий подходящий)**. Аналогичен First Fit, но начинает поиск с места последнего выделения. Полезен для систем с частыми запросами.

##### Распределение фиксированными и динамическими разделами:

**Фиксированные разделы (Fixed Partitioning)** — память делится на фиксированное количество блоков фиксированного размера при запуске системы. Каждый блок выделяется отдельному процессу (если одного блока не хватает для процесса, память просто не выделится). При таком подходе отсутствует внешняя фрагментация, зато сильно распространена внутренняя.

**Динамические разделы (Dynamic Partitioning)** — память делится на блоки переменного размера в зависимости от потребностей процессов. Блоки создаются и удаляются динамически. Это минимизирует внутреннюю фрагментацию, но может возникнуть внешняя. Как раз здесь используются алгоритмы распределения памяти.

#### 51. Алгоритмы памяти. Свопинг.

Алгоритмы выделения памяти были раньше.

**Свопинг** — это техника управления памятью, при которой данные или программы перемещаются между RAM и вторичным хранилищем, например, жестким диском или SSD, для управления ограниченным пространством RAM. Это позволяет запускать больше программ, чем может позволить физическая память. Свопинг применяется со страничной организации памяти и сегментацией.

Процесс свопинга (на примере с сегментацией):
1) Выбор неактивного процесса, когда RAM заполнена.
2) Перемещение этого процесса на диск, освобождая место в ОЗУ.
3) Если процесс снова активируется, то его можно будет загрузить с диска, возможно выгрузив неактивный процесс.

Свопинг может применяться не только для областей памяти процессов, но и для страниц (page swapping).

Свопинг это крайне требовательный процесс, сильно влияющий на производительность.

#### 52. Кэширование (в ОС).

**Кэширование** — это способ хранения часто используемых данных в быстрой памяти, например, в RAM, чтобы ускорить доступ к ним.


- **Файловый кэш**. Когда приложение запрашивает файл, ОС сначала проверяет, есть ли он в файловом кэше. Если да, данные возвращаются быстро из RAM, а не считываются с диска. В нём также применяется отложенная запись (lazy writing), когда данные записываются на диск с интервалами, что улучшает производительность, но увеличивает риск потери данных при сбоях.
- **Дисковый кэш**. Часто используется в файловых системах для хранения данных, которые недавно были прочитаны или записаны, чтобы ускорить последующие операции.

Кэширование уменьшает количество обращений, например, к ОЗУ, что снижает задержки и продлевает срок службы устройства. Но в то же время кэш требуют хороших алгоритмов для эффективной работы.

Про TLB будет дальше.

#### 53. Виртуальная память. Страничная, сегментная и сегментно-страничная организация памяти.

[[Виртуальная память]]

**Виртуальная память** — концепция, позволяющая программам работать с адресным пространством, превышающим объем физической памяти. Она обеспечивает изоляцию процессов, упрощает управление памятью и повышает эффективность использования ресурсов.

##### Страничная организация памяти:

Делит память на страничные блоки фиксированного размера, называемые страницами. 

Страницы могут находиться в физической памяти (тогда они называются страничными блоками) или быть выгруженными на диск (чтобы не занимать место). Информация о размещении страничных блоков находится в *таблице страниц*. Номер виртуальной странице является в ней ключом, а значением — смещение. Также в ней есть бит присутствия (valid). Если при обращении к таблице страниц, она оказывается выгруженной, то происходит page fault и эта страница загружается с диска. Для ускорения обращений существует TLB (translation lookaside buffer). Его можно рассматривать как кэш, только он содержит не сами данные (смещения), а расположения нужных страниц в таблице страниц. Преобразованием виртуальных адресов занимается MMU. (это если коротко, основная информация [тут](Виртуальная память))

##### Сегментная организация памяти:

**Фиксированные разделы (Fixed Partitioning)** — память делится на фиксированное количество блоков фиксированного размера при запуске системы. Каждый блок выделяется отдельному процессу (если одного блока не хватает для процесса, память просто не выделится). При таком подходе отсутствует внешняя фрагментация, зато сильно распространена внутренняя.

**Динамические разделы (Dynamic Partitioning)** — память делится на блоки переменного размера в зависимости от потребностей процессов. Блоки создаются и удаляются динамически. Это минимизирует внутреннюю фрагментацию, но может возникнуть внешняя. Как раз здесь используются алгоритмы распределения памяти.

У каждого сегмента есть базовый адрес (его начало) и предел (его конец). При обращении по виртуальному адресу, складывается виртуальный адрес (смещение) и базовый адрес. Так получается физический адрес. Информация о сегментах хранится в таблице сегментов.

При сегментной организации возникают проблемы фрагментации и производительности (из-за свопинга).

##### Сегментно-страничная организация памяти:

Виртуальное адресное пространство делится на сегменты, каждый сегмент – на страницы. Виртуальный адрес состоит из номера сегмента, номера страницы и смещения. MMU выполняет двухэтапное преобразование. Устраняется проблема фрагментации, но требует сложного преобразования. Также необходимо хранить две таблицы страниц.

#### 54. Выбор размера страниц. Выбор величины файла подкачки и его размещения (на примере Windows). Защита памяти.

Размер страницы в системе виртуальной памяти определяет, на какие блоки фиксированного размера делится виртуальное и физическое адресное пространство. В Windows стандартный размер страницы составляет **4 КБ** (4096 байт) для большинства архитектур (x86, x64), хотя в некоторых случаях поддерживаются большие страницы (например, 2 МБ или 1 ГБ).

##### Выбор размера страниц:

**Небольшой размер страниц:**
- Использование небольших размеров страниц уменьшает внутреннюю фрагментацию.
- Загрузка страниц происходит быстрее.
- Большая таблица страниц, в которой дольше производить поиск.
- TLB также сможет содержать меньше полезной информации.

**Большие страницы:**
- Внутренняя фрагментация.
- Меньше обращений к диску.
- Проще поиск по таблице страниц.
- Большее покрытие TLB (промахи случаются реже).

При выборе размера страниц также следует учитывать поддерживаемые процессором размеры страниц. У Intel x86 это 4Кб, 2Мб и 1Гб.

##### Выбор величины файла подкачки и его размещения:

Файл подкачки (pagefile.sys) в Windows — это скрытый системный файл, который используется для хранения страниц виртуальной памяти, когда физическая оперативная память (RAM) заполнена. Он также необходим для создания дампов памяти при сбоях системы (например, Blue Screen of Death).

По умолчанию Windows сам управляет размерами файла подкачки, но его также можно настроить вручную. Рекомендуется ставить от 1.5x до 3x размера ОЗУ (оптимальное 2x).

При размещении файла подкачки нужно выбрать диск с подходящим доступным объемом памяти. Также желательно разместить его на SSD. Также хорошей практикой является размещение на отдельном физическом диске, чтобы уменьшить конкуренцию за дисковые ресурсы.
##### Защита памяти:

Виртуальное адресное пространство включает в себя изоляцию адресного пространства каждого процесса, защищая его от несанкционированного доступа. Также у каждой страницы есть свои атрибуты доступа (rwx), определяющие доступные над ними действия. Перед обращением к странице MMU проверяет, можно ли выполнить команду и если нет, выдаёт исключение.

#### 55. Аппаратная поддержка механизма виртуальной памяти. Преобразование виртуальных адресов в физические.

##### Аппаратная поддержка механизма виртуальной памяти:

Аппаратным средством поддержки виртуальной памяти является MMU. Его основными задачами являются быстрое преобразование адресов и изоляция памяти.

##### Преобразование виртуальных адресов:

Представим 32-разрядную систему, с адресами в 32 бита. Современные таблицы страниц являются многоуровневыми с целью экономии памяти. Из-за этого виртуальный адрес разделяется на части: 10 бит для таблицы страниц верхнего уровня (Page Directory), 10 бит — для таблицы второго уровня (Page Table) и 12 бит — на смещение внутри страницы. Первая часть выбирает таблицу страниц, а второй саму страницу.

![[Page Table.png]]

![[Virtual --- Physical.png]]

На этой схеме 16-разрядное адресное пространство, но принцип тот же, просто в 32-разрядной системе ключами к смещению были бы сначала 10 бит адреса таблицы страниц, а затем 10 бит адреса самой страницы.

в 64-разрядной системе используются только 48 бит. По 9 бит на каждый уровень таблиц:
- PML4 — Page Map Level 4
- PDPT — Page Directory Pointer Table
- PD — Page Directory
- PT — Page Table

Перед обращением к таблице страниц MMU проверяет **Translation Lookaside Buffer (TLB)** — небольшой кэш, который хранит недавние преобразования виртуальных адресов в физические.
**TLB hit**: Если VPN найден в TLB, MMU немедленно получает соответствующий физический номер страницы (PPN) и переходит к формированию физического адреса.
**TLB miss**: Если VPN отсутствует в TLB, MMU выполняет поиск в таблице страниц, что занимает больше времени.

Если в TLB нет соответствия, MMU обращается к **таблице страниц**, которая хранится в оперативной памяти. Если номер не находится и там, то обращение идёт к файлу подкачки, который хранится на диске.

![[MMU actions.png]]

После получения PPN из таблицы страниц или TLB MMU комбинирует его со смещением из виртуального адреса, чтобы сформировать физический адрес.

Если запись в таблице страниц указывает, что страница отсутствует в физической памяти (например, она находится на диске), MMU генерирует **ошибку страницы (page fault)**. Это прерывание передаётся операционной системе. Она обновляет таблицу страниц, добавляя в неё новую запись и возвращает управление MMU.


#### 56. Защита данных при сегментной организации памяти. Исследование виртуальной памяти.

Кажется тут имелось в виду "Исследования в области виртуальной памяти".
##### Защита данных при сегментной организации памяти:

Сегментная организация памяти предполагает разделение адресного пространства на сегменты переменного размера, каждый из которых соответствует логической части программы, такой как код, данные или стек.

Каждый сегмент имеет базовый адрес и размер (лимит), которые определяют допустимый диапазон адресов. Блок управления памятью (MMU) проверяет, что любой запрос к памяти находится в пределах разрешенного сегмента. Также проверяются атрибуты доступа к сегменту (rwx).

##### Направления исследований в области виртуальной памяти:

- **Оптимизация преобразования адресов** —  исследования, направленные на:
	- Улучшения алгоритмов TLB (для увеличения количества TLB hit).
	- Организацию и применения многоуровневых таблиц страниц.
	- Использование разных размеров страниц.
- **Подкачка** — исследуются алгоритмы замены страниц. Также интересным направлением является сжатие редко используемых страниц прямо в RAM.
- **Защита памяти**
- **Поддержка виртуализации** 
- **Оптимизация работы с большими объёмами памяти** — в современных мейнфреймах могут быть терабайты оперативной памяти. Для лучшей работы с ними могут, например, сжиматься таблицы страниц.

#### 57. Принципы функционирования аппаратуры ввода-вывода. Устройства ввода-вывода и их контроллеры.

##### Устройства ввода-вывода:

**Устройства ввода-вывода** — это компоненты компьютерной архитектуры, которые обеспечивают обмен данными между компьютером и внешней средой.

Их можно разделить на две категории:
- Блочные устройства — хранят информацию в блоках фиксированной длины, у каждого из которого есть свой адрес. К каждому блоку можно обращаться независимо. К ним можно отнести жёсткие диски, флешки, компакт-диски и флоппи.
- Символьные устройства (иногда байт-ориентированные) — работают с потоком байтов. Адресация к каким-либо участкам недоступна. К ним относятся мыши, клавиатуры, сетевые карты
Есть устройства, которые нельзя отнести ни к одной из групп. Например, часы. Они не оперируют блоками данных, но и поток символов также не передаётся. Они просто генерируют прерывания через строго определённый интервал времени.

Есть два основных принципа взаимодействия системы с УВВ:
- Polling (опрос) — процессор постоянно опрашивает устройство, проверяя, готово ли оно передать данные. Такой подход прост в реализации, но не самый эффективный.
- Interrupts (прерывания) — устройство самостоятельно передаёт сигнал о готовности к передаче данных при помощи прерываний. При большом количестве прерываний, процессор может не справляться, и на помощь приходит DMA.

В UNIX системах всё является файлом, в том числе и устройства ввода-вывода. Такой подход автоматически обеспечивает единый интерфейс для взаимодействия с устройством, удобство использования с конвейерами, простоту и понятность.

В Windows всё является объектом, в том числе и устройство. Они управляются при помощи специальных дескрипторов. Такой подход обеспечивает большую гибкость.

##### Контроллеры:

**Контроллеры устройств ввода-вывода** — это электронные компоненты, которые управляют взаимодействием между устройством и центральным процессором (CPU). Они предоставляют удобный интерфейс для управлением аппаратным устройством. Процессор обращается к контроллеру устройств, которые уже взаимодействуют с аппаратной частью.

Контроллеры дисков могут обрабатывать ошибки чтения, выполнять буферизацию данных. Также они генерируют прерывания для процессора, чтобы он мог понимать, когда операция над устройством завершена. Драйвера помогают перевести команды ОС в команды для контроллера.

У контроллеров существует набор специальных регистров, через которые передаются команды и считывается состояние устройства. Есть два основных подхода взаимодействия системы с ними. При первом у каждого регистра есть свой специальный порт, к которому может обращаться только система. Таким образом, у системы появляется два различных адресных пространства: пространство общей памяти и пространство портов ввода-вывода. Второй подход использует единое адресное пространство. Регистры управления отображаются непосредственно на определённые адреса в общей памяти компьютера. В наше время более распространённым является второй подход.

##### Пример чтения данных с HDD:

**Без DMA**
1) Системой формируется запрос, который направляется к устройству (контроллеру).
2) Контроллер читает данные с диска и записывает их в свой внутренний буфер, проверяет контрольные суммы и исправляет ошибки.
3) После выполнения предыдущего шага, генерируется прерывание, которое сообщает о готовности данных.
4) Затем система при помощи регистров управления считывает данные по одному байту (по одному слову).

**С DMA**
1) Процессор программирует DMA так, чтобы он знал что нужно считать и куда записать результат.
2) Дальше запрос происходит также, как и в предыдущем примере, только посылает его DMA.
3) После того, как контроллер HDD генерирует прерывание о завершении чтения, DMA записывает данные из буфера контроллера в основную память, позволяя процессору не считывать данные самостоятельно.
4) DMA генерирует прерывание для процессора, с сообщением о завершении операции чтения.

##### Принципы:

- **Асинхронность.** Обращения к устройствам ввода-вывода должны происходить асинхронно (процессор не ждёт завершения операции).
- **Прерывания.** Контроллеры генерируют прерывания для оповещения процессора о завершении операции/ошибке и т.д.
- **Буферизация.** Часто устройства временно сохраняют некоторые значения в специальном буфере (часто где-то в/возле контроллере(-ера)) для обеспечения более быстрого доступа к данным.
- **Очереди запросов (spooling).** Если устройство занято, то запросы к нему помещаются в очередь, которой управляет контроллер.
- **Стандартизация интерфейсов.** Современные устройства используют стандартные интерфейсы подключения (USB, SATA, PCIe).

#### 58. Понятие файла. Именование, структура и типы файлов. Атрибуты и доступ к файлам, операции с файлами.

**Файл** — это именованная коллекция связанной информации, хранящаяся на вторичных носителях данных. Они представляют из себя последовательность битов. Файлы служат основным способом хранения данных, представляя пользователю и программам удобный интерфейс для работы с данными.

##### Именование файлов:

Имя файла позволяет пользователю и операционной системе находить и обращаться к файлу. Оно состоит из двух частей: имя и расширение. Например, `document.txt`: до точки имя, после – расширение.

##### Структура:

Структура определяет, организацию данных внутри файла. Она определяется расширением файла (.txt, .exe, .o, .zip).

С точки зрения файловой системы, файл представляет набор блоков данных на диске. Система хранит метаданные (данные о размере, правах, дате модификации…) и указатели на блоки, которые физически хранят данные.

##### Типы данных:

- **Текстовые файлы** — содержат вполне читаемый текст (`.txt`, `.html`)
- **Бинарные файлы** — содержат данные в двоичном виде (`.jpg`, `.exe`)
- **Исполняемые файлы** — их можно запустить как программы (`.exe`, `.sh`)
- **Директории** — каталоги)
- **Специальные файлы** — в UNIX-подобных системах файл является очень распространенным видом абстракции. Практически всё в UNIX это файл. В том числе и устройства ввода/вывода. Они и считаются специальными. (`/dev/sda`)

##### Атрибуты файлов:

**Атрибуты файла** — это метаданные, которые предоставляют дополнительную информацию о файле и используются операционной системой для его управления.

- Имя
- Идентификатор (inode в Linux)
- Тип
- Расположение
- Размер
- Защита (информация о правах)
- Даты создания, последнего изменения, последнего доступа
- Владелец

##### Доступ к файлам:

Доступ регулируется системой, на основе прав доступа, которые хранятся в метаданных файла. Например в UNIX используется `rwx`. Каждому праву (read, write, execute) присваивается бит. Есть бит – есть право. Например, `110` --> `rw-`. `-` на месте `x` означает что права execute (запуск) нет. Права хранятся в виде: `rwxr-xr-x`. Таким образом они определяют доступные действия для владельца, группы и остальных.
Windows использует ACL — списки контроля доступа.

##### Операции с файлами:

- **Создание** — `touch файл`
- **Чтение содержимого** — `cat файл`
- **Запись (перезапись)** — `echo "текст" > файл`
- **Добавление в конец** — `echo "ещё текст" >> файл`
- **Удаление** — `rm файл`
- **Переименование** — `mv старое_имя новое_имя`
- **Копирование** — `cp исходный_файл копия`
- **Перемещение** — `mv файл путь/новое_место`
- **Изменение прав доступа** — `chmod 755 файл`

#### 59. Понятие каталога. Иерархические каталоговые системы. Операции с каталогами.

**Каталог** — это структура данных в файловой системе операционной системы, которая содержит ссылки на файлы и другие каталоги

##### Иерархические каталоговые системы:

Иерархические каталоговые системы организуют каталоги и файлы в древовидную структуру. Такая структура начинается с корневого каталога (в UNIX это `/`, в Windows – `C:\` (или другая буква)). 

**Абсолютный путь** — полный путь от корневого каталога, например, `/home/user/documents` или `C:\Users\Имя\Documents`.

**Относительный путь** — путь относительно текущего каталога, например, `documents` из `/home/user`.

##### Операции над каталогами:

- Создание — `mkdir`
- Удаление — `rmdir`
- Переименование — `mv`
- Навигация — `cd`
- Просмотр содержимого — `ls`
- Установка прав доступа — `chmod`
- Копирование и перемещение  — `cp`

#### 60. Задачи ОС по управлению файлами и устройствами.

##### Управление файлами:

- ОС организует файлы в иерархическую файловую систему.
- ОС хранит метаданные файлов.
- Предоставление интерфейса для удобного взаимодействия с файлами.
- Защита данных (права доступа, шифрование).
- Резервное копирование.

##### Управление устройствами:

- ОС автоматически обнаруживает подключенное устройство и загружает драйверы для него. 
- Управление операциями ввода-вывода.
- Распределяет доступ к устройствам между процессами и пользователями, предотвращая конфликты.
- Оптимизирует использование устройств, минимизируя задержки. Например, для дисков она использует кэширование для ускорения доступа к данным.
- Выявляет ошибки устройств и пытается их исправить, например, повторным запросом.

#### 61. Структура файловой системы. Примеры ФС. Реализация файлов и каталогов (папок). Распределенная файловая система.

**Файловая система** — это метод, используемый операционной системой для организации и управления файлами и каталогами на устройстве хранения. Файловая система действует как мост между ОС и физическим носителем, предоставляя доступ к файлам и обеспечивая защиту.

Большинство файловых систем используют иерархическую структуру.

##### Компоненты ФС:

- **Суперблок** — содержит метаданные о файловой системе, такие как ее тип, размер и состояние.
- **Inodes (в Unix-подобных системах)** — индексные узлы, хранящие метаданные о файлах и каталогах.
- **Каталоги** — содержат файлы (ссылки на inodes) и образуют иерархию.

##### Примеры ФС:

- **FAT (File Allocation Table)** — устаревшая система, простая структура, но ограниченный размер (4 ГБ в FAT32)
- **NTFS (New Technology File System)** — стандартная ФС Windows. Поддерживает большие файлы, права доступа, сжатие, шифрование и журналирование для восстановления данных.
- **ext4 (Fourth Extended File System)** — основная файловая система в Linux. Поддерживает все современные функции.
- **APFS (Apple File System)** — современная файловая система macOS.
- **XFS** — высокопроизводительная файловая система для Linux, используемая в серверных средах.

##### Реализация файлов:

**Inode** является низкоуровневым представлением файла. Он содержит метаданные:
- тип файла (обычный файл, каталог, символьная ссылка, устройство)
- права доступа
- информацию о владельце
- размер файла
- временные метки
- количество жёстких ссылок 
- адреса блоков данных.

В UNIX-подобных системах у файла есть имя, которое сопоставляется с номером inode. В Windows они хранятся в MFT (Master File Tables), где каждая запись описывает файл или каталог.

##### Реализация каталогов:

Каталоги в UNIX являются файлом с типом `directory`. Они содержат имя и ссылку на метаданные.

##### Распределённые системы:

**Распределенная файловая система (DFS)** — это файловая система, которая позволяет нескольким компьютерам совместно использовать файлы через сеть, как если бы они находились на локальном диске.

Такая система может быть удобной для системы устройств (распределённой системы). Сетевые операции могут быть медленнее локальных, поэтому могут присутствовать задержки. Репликация данных делает утерю данных менее возможной.

#### 62. Управление дисковыми ресурсами (на примере Windows, Linux). RAID - массивы.

##### Управление дисковыми ресурсами:

- **Настройка инициализации**. ОС позволяет настроить процесс инициализации диска, включая выбор разделочной таблицы (MBR или GPT).
- **Файловая система**. ОС определяет файловую систему диска, это определяет структуру хранения данных на диске.
- **Управление разделами**. ОС позволяет производить создание, удаление, форматирование разделов и томов.
- **Управление данными на диске**. Включая форматирование.

В Windows основным средством управления дисками является **Disk Managment**. Для вызова утилиты используется команда: `diskmgmt`.

В Linux управление происходит с помощью разных утилит. Основные:
- fdisk — управление разделами
- lsblk — список дисков
- mount — монтирование диска
- mkfs — форматирование диска под определённую ФС.
- parted — также управление разделами

LVM!!!!

##### RAID-массивы

RAID (Redundant Array of Independent Disks) — это технология, которая объединяет несколько физических дисков в один логический массив для повышения производительности и надёжности. RAID может быть организован программно или аппаратно.

Изначально RAID расшифровывался как Redundant Array of Inexpensive Disks и противопоставлялся SLED (Single Large Expensive Disk). Когда надёжные диски стоили очень дорого, возникла идея о создании системы из множества дешёвых дисков в связке. С помощь программных или аппаратных средств, такая структура могла обеспечить производительность и надёжность на уровне или даже лучше чем SLED. В наше время RAID-массивы используются для других целей.

RAID-массивы разделяются на 7 стандартных конфигурации, которые часто называются уровнями:

- **RAID 0** — чередование (striping). Представим RAID-массив из двух дисков. Данные разбиваются на блоки и записываются на каждый блок поочерёдно (в каком-то смысле). Например, первый и второй блок записываются на первый и второй диск соответственно в один такт. Из-за возможности параллельной записи скорость увеличивается, также используется объём двух дисков. Но RAID 0 это не надёжная система, ведь если один диск выйдет из строя, то считай все данные будут утеряны.
- **RAID 1**. Каждый *блок* данных дублируется на другой диск. Это обеспечивает большую надёжность данных, повышенную производительность чтения, но плохую скорость записи и объём (используется $\Huge\frac{100\%}{n}$ пространства)
- **RAID 2** — основывается на коррекции ошибок на уровне битов, с помощью кодов Хэмминга. Данные разбиваются по *битам*. Одни диски используются для хранения бит данных, другие для хранения битов коррекции ошибок. Система устарела до того, как начала применяться.
- **RAID 3**. Представим RAID-массив из 4 дисков. На 3 диска по очереди *побитово* записываются данные (по принципу RAID 0). Последний диск хранит контрольную информацию (чётность), обычно, используя XOR. Таким образом, при потере одного диска, можно будет восстановить его содержимое. Характеризуется хорошей надёжностью.
- **RAID 4**. Работает по принципу RAID 3, только с *блоками* данных. При такой реализации улучшается скорость чтения. В RAID 3 и 4 диск для чётности – узкое место при записи.
- **RAID 5** — самый популярный вариант. Данные разбиваются по блокам и распределяются по всем дискам (чередованием). Вычисляется контрольная сумма и также записывается на один из дисков. По таблице видно что контрольная сумма может записаться на любой диск. Если один из них будет утерян, то данные можно будет восстановить.
![[RAID 5.png]]
- **RAID 6**. Это расширение RAID 5, с добавленной второй чётностью, обеспечивая возможность восстановления при потере двух дисков. P – контрольная сумма, Q – более сложная схема чётности.
![[RAID 6.png]]
- **RAID 10** — RAID 0 + RAID 1. Для функционирования нужно минимум 4 диска. Данные записываются чередованием на 2 диска, а оставшиеся 2 дублируют информацию.

#### 63. Форматирование дисков. Фрагментация памяти, дефрагментация дисков.

##### Форматирование дисков:

**Форматирование дисков** — это программный процесс разметки области хранения данных на носителях, таких как жесткие диски (HDD), твердотельные накопители (SSD), USB-флешки или оптические диски. Оно создаёт структуру доступа к данным, называемую файловой системой. Форматирование приводит к потере данных на устройстве.

**Низкоуровневое форматирование** — производится на заводе-изготовителе. Создаёт физические дорожки и сектора на диске.

**Высокоуровневое форматирование** — создаёт файловую систему, может включать проверку диска на работоспособность. Выполняется пользователями. Бывает *быстрое форматирование*, при котором диск не проверяется на дефекты, просто удаляя таблицу файловой системы и полное форматирование — проверяет диск на наличие дефектных секторов, создаёт новую файловую систему и может занять значительно больше времени.

##### Фрагментация памяти:

В контексте дисков фрагментация относится к файлам, которые хранятся в несвязных блоках, что замедляет операции чтения и записи.

**Внутренняя фрагментация** — возникает, когда выделенный блок памяти больше, чем требуется для данных, и часть пространства остается неиспользованной.

**Внешняя фрагментация** — происходит, когда свободное пространство разбивается на мелкие блоки, недостаточные для хранения больших файлов, даже если общее свободное пространство достаточно.

##### Дефрагментация дисков:

**Дефрагментация дисков** — это процесс переупорядочивания данных на диске, при котором фрагментированные файлы собираются в последовательные блоки, что ускоряет доступ к ним. Это особенно важно для жестких дисков (HDD), где линейное чтение данных минимизирует перемещение головок. Дефрагментация SSD сделает только хуже.

На HDD файлы записываются в виде блоков. Если рядом нет достаточно свободного места, файл разбивается на части и размещается в разных областях. Из-за этого части программы могут находиться далеко друг от друга, и считывающая головка будет долго перемещаться между ними. Для избегания подобных ситуаций и проводится дефрагментация.

Дефрагментацию проводят специальные программы —  **дефрагментаторы**. В Windows и Linux есть встроенная утилита. Файловая система Linux (ext4 и brtfs) слабо фрагментируются, поэтому дефрагментация будет не такой эффективной.
#### 64. Дисковое планирование.

**Дисковое планирование** — это механизм, который операционная система использует для управления очередью запросов на операции ввода-вывода к диску. Благодаря ему сокращается время выполнения запросов, обеспечивается справедливое распределение ресурсов, уменьшается износ физических частей HDD, производится равномерный износ памяти в SSD.

##### Основные алгоритмы:

- **First-Come, First-Served (FCFS)** — простой, справедливый алгоритм. Могут требовать большого количества перемещений головки.
- **Shortest Seek Time First (SSTF)** — сокращается время перемещения головки. Может вызывать старвацию. Также требуются вычисления для нахождения ближайшего запроса.
- **SCAN (Elevator Algorithm)** — головка движется только в одном направлении, обслуживая все запросы по пути, затем меняет направление (практически как лифт). Обладает достаточно хорошей справедливостью, но запросы на дальних концах могут ждать дольше. Также могут возникать лишние перемещения, если в текущем направлении движении не останется запросов (алгоритм не будет об этом знать и дойдёт до конца).
- **C-SCAN (Circular SCAN)** — вариант SCAN, где после достижения конца диска головка сразу переходит к началу, не обслуживая запросы по пути обратно, и начинает обслуживать запросы в том же направлении (вот это уже точно алгоритм лифта). Подходит для систем с постоянным потоком запросов, но плохо работает со случайными запросами.
- **LOOK** — аналог SCAN, но головка останавливается на последнем запросе в текущем направлении, не доходя до конца диска, и меняет направление. Это позволяет избавиться от лишних движений головки.
- **C-LOOK** — сочетает C-SCAN и LOOK.

В современных системах, при выполнении запроса, часто, считывается сразу несколько секторов (часто большую часть дорожки) в кэш контроллера.

#### 65. Команды работы с файлами. Работа с пакетными файлами.

| **Операция**          | **Windows (cmd)** | **Linux (bash)** |
|-----------------------|-------------------|------------------|
| Список файлов         | `dir`             | `ls`             |
| Копирование файлов    | `copy`, `xcopy`   | `cp`             |
| Перемещение файлов    | `move`            | `mv`             |
| Удаление файлов       | `del`             | `rm`             |
| Переименование файлов | `ren`             | `mv`             |
| Просмотр содержимого  | `type`            | `cat`            |
| Запись в файл         | `echo`            | `echo`           |
| Создание директории   | `md`, `mkdir`     | `mkdir`          |
| Удаление директории   | `rd`, `rmdir`     | `rmdir`, `rm -r` |

##### Работа с пакетными файлами:

**Пакетные файлы (batch files)** — это текстовые файлы с расширением .bat или .cmd, содержащие последовательность команд, которые выполняются командным интерпретатором Windows (cmd). Аналог в Linux — скрипты (`.sh`).

```
@echo off
set /p name=Введите ваше имя:
if "%name%"=="Admin" (
  echo Добро пожаловать, администратор.
) else (
  echo Привет, %name%.
)

```

`@echo off` — отключает отображение команд в консоли, показывая только их вывод.
`%name%` — так происходит обращение к переменным.

#### 66. Понятие компьютерной сети. Преимущества объединения. Типы сетей. Терминология компьютерных сетей.

**Компьютерная сеть** — это совокупность компьютеров, серверов, сетевых устройств и другого оборудования, соединённых между собой.

##### Преимущества объединения:

- **Совместное использование ресурсов**
- **Упрощение коммуникации**
- **Доступ к удаленным ресурсам**
- **Централизованное управление**
- **Распределенные вычисления**

##### Типы сетей:

**Локальная сеть (LAN — Local Area Network)** — ограничена небольшой территорией (комната, здание). Характеризуется высокой скоростью передачи данных и небольшим количеством устройств.

**Сеть масштаба города (MAN — Metropolitan Area Network)** — охватывает территорию города или его части. Может соединять несколько локальных сетей в разных зданиях или районах. (Например сеть городского видеонаблюдения)

**Глобальная сеть (WAN — Wide Area Network)** — соединяет сети на больших расстояниях. В разных городах, странах, континентах. Самая большая глобальная сеть — это интернет.

**Персональная сеть (PAN — Personal Area Network)** — соединяет устройства одного пользователя, такие как смартфон, ноутбук и наушники, обычно через Bluetooth или USB. Охватывает до 10 метров.

**Глобальная сеть (GAN — Global Area Network)** — поддерживает мобильные устройства через беспроводные LAN и спутниковую связь.

##### Терминология:

| **Термин**            | **Описание**                                                               |
|-----------------------|----------------------------------------------------------------------------|
| Узел                  | Устройство, подключенное к сети (компьютер, сервер, принтер)               |
| Протокол              | Правила обмена данными (TCP/IP, HTTP, FTP)                                 |
| Топология             | Схема соединения устройств (звезда, кольцо, шина, сетка)                   |
| Пропускная способность | Максимальная скорость передачи данных (бит/с)                             |
| Задержка              | Время передачи данных от отправителя к получателю                          |
| IP-адрес              | Уникальный идентификатор устройства в сети                                 |
| Пакет                 | Единица данных, содержащая управляющую информацию и полезную нагрузку      |
| Маршрутизатор         | Устройство для передачи данных между сетями                                |
| Коммутатор            | Устройство для соединения устройств внутри сети                            |
| Брандмауэр            | Система для защиты сети от несанкционированного доступа                    |

#### 67. Распределенные вычисления и распределенные системы. Вычисления в архитектуре клиент-сервер. Двухзвенная и трехзвенная архитектуры.

##### Распределенные вычисления и распределенные системы:

**Распределенные вычисления** — это область компьютерных наук, изучающая системы, где компоненты расположены на разных компьютерах и взаимодействуют через сеть для достижения общей цели. Распределенные системы состоят из автономных узлов (у каждого свой процессор, память и т.д.), которые обмениваются сообщениями для координации действий. Большое количество узлов обеспечивает большую вычислительную мощность, при отказе одного из них система продолжит работать. Это обеспечивает эффективность и надёжность системы.

Примеры систем:
- **Torrent сети** — обеспечивают передачу данных без участия единого сервера. Файл собирается с разных пользователей.
- **DNS** — нет единого центра, множество уровней (root, TLD, авторитетные DNS-серверы).

##### Вычисления в архитектуре клиент-сервер:

Архитектура клиент-сервер — это модель, где клиент (обычно пользовательское устройство, такое как ПК или смартфон) запрашивает услуги у сервера, который их предоставляет. Например, такой механизм применяется в веб-браузинге. Запросы осуществляются через интернет при помощи различных протоколов.

##### Двухзвенная и трехзвенная архитектуры:

Двухзвенная и трехзвенная архитектуры — это способы организации клиент-серверных систем.

**Двухзвенная архитектура** — клиент напрямую взаимодействует с сервером, где сервер управляет данными. Например, подключение к базе данных напрямую.

**Трехзвенная архитектура** — добавляется уровень между клиентом и сервером. Например, пользовательский интерфейс для более удобного доступа к БД.

#### 68. Удаленный вызов процедур Примеры реализации RPC.

**RPC** — это протокол, позволяющий программе выполнять процедуры на удаленном сервере, как если бы они были локальными.

##### Примеры реализации:

- **gRPC** (от Google) — основан на HTTP/2 и Protocol Buffers.
- **XML-RPC** — основан на HTTP и передаёт данные в виде XML.
- **JSON-RPC** — похож на XML-RPC, но использует JSON.

#### 69. Кластерная архитектура.

**Кластерная архитектура** — это способ объединения нескольких компьютеров, чтобы они работали как одна система. Такая система состоит из узлов (компьютеры или серверы), соединений между ними и специальным ПО для организации компьютеров в единое целое.

Кластерная архитектура отличается от распределённых систем:
- В кластерной системе узел обычно работает только над одной, определённой задачей, в отличии от распределённых систем, где за узлами не закреплена задача.
- Строение компьютеров в кластерных системах часто одинаковое. В распределённых системах комплектующие узлов могут сильно различаться.
- Обычно кластерные системы управляются единым ПО со строгой централизацией. В распределённых системах возможна децентрализация и автономность узлов.
- Кластерная система передаёт данные по локальной сети, а распределённые системы – по интернету.

Кластерная архитектура может также быть децентрализованной. В таком случае узлы будут обмениваться данными напрямую друг с другом (а не через центральный координатор).

#### 70. Виртуальные файловые системы VFS.

**Виртуальная файловая система (VFS)** — это абстрактный уровень файловой системы, реализованный в ядре операционной системы, который обеспечивает единый интерфейс для различных типов реальных (физических) файловых систем. Она позволяет программам работать с файлами и каталогами независимо от того, на какой конкретной файловой системе (ext4, FAT, NTFS и т. д.) они расположены.

VFS предоставляет единый API для всех файловых систем. Программы используют стандартные системные вызовы (`open()`, `read()`, `write()`), не заботясь о типе файловой системы.

Виртуальная файловая система реализует абстрактные структуры данных, такие как:
- `superblock` — информация о всей файловой системе.
- `inode` — информация о каждом объекте (файле, каталоге).
- `dentry` — запись о каталоге.
- `file` — открытый файл.
При монтировании реальной файловой системы её драйвер преобразует физические структуры в объекты VFS, при помощи которых в дальнейшем с ними взаимодействует.

#### 71. Сетевая файловая система NFS.

**NFS (Network File System)** — это сетевая файловая система, которая позволяет компьютерам обращаться к файлам на удалённом сервере так, как будто они находятся на локальном диске.

Работает по протоколу TCP/IP. Использует клиент-серверную модель. Интегрируется через VFS, как и обычные файловые системы (удалённый каталог монтируется в локальную ФС).

Например, когда клиентская ФС выполняет команду `read()`, VFS передаёт запрос драйверу NFS, который отправляет запрос на сервер, который читает блок данных и возвращает его клиенту.

#### 72. Службы каталогов Active Directory. Репликация. Межсетевое взаимодействие.

**Службы каталогов Active Directory (AD)** — это технология Microsoft, используемая для управления доступом и разрешениями в сетевых средах Windows. Она обеспечивает централизованное хранение и управление информацией о пользователях, компьютерах и других сетевых ресурсах. Active Directory предоставляет централизованный интерфейс для управления учетными записями, правами доступа и ресурсами в больших локальных (LAN) и городских (MAN) сетях.

**Каталог** — это база данных, в которой хранится информация (например права доступа) обо всех объектах и ресурсах в сети, управляемых через AD.

**Доменная среда Windows** — сеть устройств, использующих AD.

**Домен** — это логическая группа компьютеров, распределённая по каким-либо критериям, например, с географическим расположением или политикой безопасности.

**Контроллеры домена (DC**) — серверы, на которых установлена служба Active Directory Domain Services (AD DS). Он отвечает за аутентификацию, авторизацию и хранение данных каталога в доменной среде Windows.

Ключевой аспект работы AD — **репликация**, которая гарантирует, что все контроллеры домена (DC) в домене или лесу имеют одинаковые данные. Например, если в сети 5 DC, то они будут содержать одинаковые данные. Репликация обеспечивает хранение синхронизированной копии каталога Active Directory.

Репликация бывает:
- **Внутрисетевая (Intra-Domain Replication)** — происходит в пределах одного домена. Изменения реплицируются довольно быстро (обычно каждые 15 секунд).
- **Межсетевая** (Inter-Domain Replication) — происходит между разными доменами. Изменения реплицируются с большим промежутком времени (обычно 3 часа).

В условиях, когда организация имеет несколько сетей или физических локаций, AD использует понятие сайтов (sites) для оптимизации работы.
**Сайт** — это логическая группировка подсетей, соединенных высокоскоростными каналами связи. Его можно рассматривать так топологию (схему) подсетей.

Межсетевое взаимодействие происходит с помощью сайтов и их связей между собой. Они помогают передавать данные более эффективно.

#### 73. Понятие безопасности. Требования по безопасности. Внешняя и операционная безопасность. Угрозы, злоумышленники, случайная потеря данных. Предотвращение проблем во внешней среде.

##### Понятие безопасности:

**Безопасность** — это практика защиты информации от несанкционированного доступа, использования, раскрытия, нарушения, изменения или уничтожения.

Принципы безопасности (триада CIA):
- **Конфиденциальность** (Confidentiality) — информация не доступна неавторизованным лицам.
- **Целостность** (Integrity) — поддержание точности и полноты данных, предотвращение несанкционированных изменений.
- **Доступность** (Availability) — авторизованные пользователи имеют доступ к информации, когда это необходимо.

Принципы управления идентификации и доступом (по Васильеву):
- **Аутентификация** — проверка личности.
- **Авторизация** — предоставление уровня доступа аутентифицированному лицу.
- **Администрирование** — управление доступом пользователя к информации.
- **Аудит** — проверки, подтверждающие что все предыдущие принципы соблюдены.

##### Требования по безопасности:

- **Контроль доступа** — разграничение прав пользователей.
- **Аутентификация** — проверка подлинности пользователя.
- **Журналирование** — отслеживание действий.
- **Резервное копирование** — защита от потери данных.
- **Шифрование** — защита данных от перехвата и подмены.
- **Антивирусная защита и обновления** — устранение уязвимостей.

##### Внешняя и операционная безопасность:

**Внешняя безопасность** — защита от внешних угроз, таких как хакеры, вредоносное ПО и фишинговые атаки. К мерам относится использование брандмауэров и систем обнаружения вторжений, шифрование данных при передаче.

**Операционная безопасность** — защита внутренних операций и данных от как внешних, так и внутренних угроз. Например, ошибки персонала, внутренние злоумышленники и т.д.

##### Угрозы, злоумышленники, случайная потеря данных:

**Примеры угроз:**
- Вредоносное ПО.
- Физическое разрушение (пожар, затопление).
- Перехват информации.
- Саботаж и инсайдерские атаки.

**Примеры злоумышленников:**
- Внешние хакеры.
- Недовольные сотрудники.
- Конкуренты.
- Случайные нарушители.

**Случайная потеря данных** может произойти из-за человеческого фактора, отказа оборудования, ошибки ПО.

##### Предотвращение проблем во внешней среде:

Необходимо соблюсти меры защиты:
- Использование [[Firewall]] и антивирусов.
- Постоянное обновление ПО.
- Сканирование уязвимостей.
- Резервное копирование.
- Защита от внутреннего доступа (со стороны сотрудников).
- Создание аварийного плана восстановления.
- Использование надёжных паролей.
- Шифрование отправляемых данных.
- Отключение ненужных служб.
- Отказ от небезопасных протоколов.

#### 74. Аутентификация пользователей, права доступа, пароли.

**Аутентификация** — это процесс подтверждения личности пользователя перед предоставлением доступа к системе или ресурсам. Обычно она происходит по логину и паролю.

**Права доступа** определяют, что пользователь может делать в системе после аутентификации, например, читать файлы, изменять настройки или управлять другими пользователями. Для безопасности системы необходимо выдавать минимально необходимые права пользователю.

**Пароль** — это секретная комбинация, используемая для аутентификации. Они должны быть надёжными.

#### 75. Архивация данных.

Если учитывать контекст предыдущих билетов, то тут идёт речь про архивацию как "откладывание в дальний ящик".  При этом программы для сжатия файлов при этом также могут использоваться.

**Архивация данных** — это процесс перемещения неактивных или исторических данных в отдельное хранилище для долгосрочного хранения. В отличие от резервного копирования, которое предназначено для краткосрочного восстановления данных в случае потери, архивация фокусируется на хранении данных, которые больше не используются активно, но должны быть доступны для будущих ссылок, аудитов или анализа. Данные архивируются в низкозатратные системы хранения.

Освобождение пространства в основной системе, ускоряет её работу. Низкозатратные системы позволяют дёшево хранить большие объёмы данных (но медленный доступ к ним).

Многие отрасли требуют хранения данных в течение определенного периода. Например, HIPAA (Закон о переносимости и подотчетности медицинского страхования) требует хранения медицинских данных в течение 6 лет. Архивация помогает обеспечить соответствие таким требованиям.

#### 76. Облачное хранение данных. Гиперконвергенция.

**Облачное хранение** — это способ сохранения данных на удалённых серверах, к которым можно получить доступ через интернет. За сохранность данных отвечает провайдер.

**Гиперконвергенция** — это ИТ-инфраструктура, она используется для обеспечения работы корпоративных и облачных вычислений.

**Гиперконвергентная инфраструктура (Hyper-Converged Infrastructure)** — инфраструктура, в которой серверы, хранилище и сеть объединены программно в единое устройство (узел), управляемое централизованно через ПО.

Также существуют конвергентные структуры, в которых вычислительные ресурсы, хранение данных и сеть поставляются как отдельные, но согласованные компоненты (они физически разделены, но хорошо между собой совместимы и оптимизированы для совместной работы). Они реализуются аппаратно.

**Традиционная система** — та, в которой все компоненты разделены и управляются отдельно.

![[HCI.png]]

#### 77. Система Kerberos.

**Kerberos** — это протокол аутентификации в сети, разработанный для обеспечения безопасного доступа к ресурсам в распределенных системах. Он использует секретный ключевой шифр для проверки подлинности пользователей и сервисов, не передавая пароли по сети. Kerberos предназначен для аутентификации запросов сервисов между доверенными хостами через ненадежные сети, такие как интернет.

Принцип работы:
1) Запрос на аутентификацию. Пользователь вводит логин и пароль на локальном клиенте. Отправляется запрос в открытом виде на KDC (Key Distribution Center) (запрос содержит только логин, пароль остаётся исключительно на клиенте). KDC выдаёт билет (Ticket Granting Ticket – TGT), зашифрованный ключом, который генерируется при помощи алгоритма криптографического хэширования из пароля (который, напоминаю, всё время лежал на клиенте). Если пароль неправильный — расшифровка не удаётся.
2) Когда требуется получить доступ к конкретному сервису, клиент отправляет TGT к Ticket Granting Server (TGS), также части KDC, запрашивая сервисный билет. TGS проверяет TGT и выдает сервисный билет, зашифрованный ключом сервиса.
3) Клиент представляет сервисный билет сервису, который расшифровывает его и, если билет действителен, предоставляет доступ к ресурсу.

#### 78. Предотвращение сбоев и отказов. Система резервного копирования: требования и задачи.

Сбои могут быть вызваны:
- Аппаратные неисправности (поломки).
- Программные ошибки (например из-за обновлений).
- Кибератаки.
- Природные катастрофы.

Одним из способов защиты данных является резервное копирование.

Существует две важные переменные в восстановлении после сбоев:
- **RPO (Recovery Point Objective)** — целевая точка восстановления. Отвечает на вопрос: "Сколько данных можно потерять?" (например, 4 часа данных).
- **RTO (Recovery Time Objective)** — целевое время восстановления. Отвечает на вопрос: "Как быстро нужно восстановить работу".

##### Стратегии резервного копирования:

- **Полное резервное копирование (Full Backup)** — копируются все данные. Из-за этого процесс медленный и backup занимает много места.
- **Инкрементальное резервное копирование (Incremental Backup)** — копируются **только изменения** с момента последнего резервного копирования. Это экономит много времени, но восстановление происходит медленнее, ведь нужно восстанавливать каждый этап.
- **Дифференциальное резервное копирование (Differential Backup)** — первый раз выполняется полное копирование, а при последующих операциях копируется только обновлённая информация.
- **Смешанное инкрементальное копирование** — создаёт полную копию данных, а затем указанное количество инкрементальных копий в течение указанного промежутка времени. По истечении этого промежутка весь цикл повторяется, начиная с создания полной копии данных.
- **Зеркальное резервное копирование** — все новые или изменённые данные копируются из одной синхронизируемой папки в другую. При зеркальном типе копирования (двухсторонней синхронизации папок) происходит взаимное обновление содержимого папок.

##### Задачи

- Защита от аппаратных сбоев.
- Защита от человеческих ошибок.
- Защита от вирусов и воздействия вредоносного ПО.
- Защита от кибератак.
##### Принципы:

- **Регулярность и частота**.
- **Раздельность резервных копий**. Они должны находиться далеко от источника (если резервная копия устройства будет храниться на нём же, то при его выходе из строя данные будут утеряны).
- **Перепроверка**. Должны проводиться тестовые восстановления.
- **Деление резервных копий по категориям**.
- **Принцип резервного копирование ОС**. Основную ценность составляет её конфигурация.
- **Выбор надёжного места для хранения**.
- **3-2-1**. Три резервные копии, в двух различных физических форматах хранения (например HDD и SSD), причём одна из копий должна быть передана на внеофисное хранение.

#### 79. Безопасный режим загрузки. Восстановление конфигурации.

**Безопасный режим** — это специальный режим загрузки Windows, который запускает систему с минимальным набором драйверов и служб. Это полезно для диагностики и устранения неполадок, таких как проблемы с драйверами, вирусами или некорректными настройками. Войти в него можно либо через `msconfig`, либо через среду восстановления.

**Восстановление конфигурации** — откат системы к предыдущему сохранённому состоянию. Производится через среду восстановления.

#### 80. Диагностика отказов при загрузке операционной системы на примере Windows, Linux. Сообщения Windows и Linux и стратегия отладки.

##### Windows:

Ошибки при загрузке системы:
- **BOOTMGR is missing** — проблема с загрузчиком.
- **INACCESSIBLE_BOOT_DEVICE** — система не может получить доступ к диску.
- **0xc000000f** (Boot Configuration Data) — Повреждён файл BCD.
- Automatic Repair couldn’t repair — система не смогла восстановиться автоматически.
- Blue Screen of Death (BSOD) — критическая ошибка драйвера, железа или ядра.

Для восстановления системы используется среда восстановления. В ней можно выполнить откат до последнего безопасного состояния системы. Также можно использовать различные команды в CMD.

##### Linux:

Распространённые ошибки:
- **GRUB Rescue** — ошибка загрузчика GRUB.
- **Kernel panic - not syncing** — ошибка ядра или отсутствие root-устройства.
- **Waiting for root device…** — устройство корневой файловой системы не найдено.
- **Filesystem check failed** — повреждена файловая система.

Они устраняются различными командами. Например можно переустановить GRUB, перемонтировать диск и т.д.


#### 81. Требования, предъявляемые к серверным операционным системам. Серверная операционная система Windows Server. Ubuntu Server.

##### Требования:

- **Стабильность и надёжность**.
- **Безопасность**. ОС должна включать мощные механизмы защиты данных и приложений.
- **Масштабируемость**. Увеличение нагрузки и числа пользователей.
- **Инструменты администрирования**.
- **Производительность**.
- **Поддержка нескольких пользователей**.
- **Поддержки виртуализации**.
- **Механизмы резервного копирования**.
- **Поддержка различных сетевых протоколов**.

##### Windows Server:

Имеет графический интерфейс. Поддерживает Actve Directory.Из преимуществ можно отметить простой GUI и интеграцию сервисов Microsoft. из недостатков –  высокую цену лицензирования.

##### Ubuntu Server:

Гибкая, производительная система с большим сообществом и открытым кодом (бесплатная). Но присутствует только CLI интерфейс и из-за этого настройка происходит сложнее.

#### 82. Системная интеграция: понятие, типы, методы.

**Системная интеграция** — процесс объединения различных аппаратных и программных компонентов в единую, целостную и функционирующую информационную систему. Цель — обеспечить совместную работу всех компонентов, включая ОС, прикладное ПО, драйверы, службы, сети и устройства.

Интеграцией может являться установка ПО, настройку аппаратного обеспечения (интеграция устройств) и т.д.

| Тип интеграции            | Описание                                                                           |
| ------------------------- | ---------------------------------------------------------------------------------- |
| **Аппаратно-программная** | Интеграция ОС с устройствами (установки драйверов, BIOS/UEFI настройки)            |
| **Программная**           | Взаимодействие между ОС и прикладным ПО, сервисами, библиотеками                   |
| **Сетевая**               | Интеграция ОС в локальные и глобальные сети, настройка сетевых протоколов          |
| **Кросс-платформенная**   | Интеграция разных ОС между собой (например, общие сетевые ресурсы Windows и Linux) |
| **Интеграция с облаками** | Связь ОС с облачными сервисами (например, Active Directory)                        |

| Метод                        | Примеры                                                                               |
| ---------------------------- | ------------------------------------------------------------------------------------- |
| **API-интеграция**           | Использование API ОС (например, WinAPI, POSIX) для связи с ПО                         |
| **Драйверная интеграция**    | Подключение аппаратных устройств через драйверы ОС                                    |
| **Сетевые протоколы**        | Интеграция через TCP/IP, SMB, NFS, SSH, RDP                                           |
| **Службы и демоны**          | Настройка служб Windows (службы) или демонов в Linux (systemd, cron)                  |
| **Виртуализация**            | Интеграция с помощью виртуальных машин (Hyper-V, VirtualBox) или контейнеров (Docker) |
| **Сценарии и автоматизация** | Bash/PowerShell скрипты, Ansible, Puppet, для автоматизации настройки ОС              |

#### 83. Производительность, загрузка центрального процессора (ЦП) пользовательскими процессами и программами ядра, распределение времени ЦП между процессами, использование ОЗУ и виртуальной памяти пользовательскими процессами, число операций ввода-вывода и их распределение по процессам, активность дисков, очередь к дискам и др.

**Производительность** — способность системы справляться с нагрузками. По различным метрикам (использование CPU, памяти, операций I/O) можно выявить узкие места, что позволит повысить эффективность системы.

**Загрузка ЦП** — ключевой показатель, отражающий, сколько времени CPU тратится на различные процессы.

Выделением времени занимается планировщик. По него написано [тут](Планирование).

Информацию о загрузке процессора и распределении процессорного времени между процессами (пользовательскими и системными) в Linux можно при помощи команд `top` и `ps`.

Информацию об использовании ОЗУ в Linux можно получить при помощи команд `free -m` (показывает объём используемой и свободной памяти) и `vmstat 5` (выводит большое количество информации о памяти в системе, которая обновляется каждые 5 секунд).

Информация о производительности I/O устройств выводится командой `iostat -x 5` (обновляется каждые 5 секунд). С её же помощью можно узнать о активности дисков и очереди к ним.

В Windows вся информация находится в диспетчере задач.

#### 84. Инструменты мониторинга и оптимизации Windows/Linux.

**Мониторинг** — это процесс непрерывного наблюдения, сбора, анализа и отображения информации о состоянии системы.

##### Мониторинг системы:

**Windows:**
- Диспетчер задач — информация о загрузке ЦП, памяти, сети и т.д.
- Монитор ресурсов — те же самые сведения, но подробнее.
- Системные монитор — предназначен для долгосрочного мониторинга. (про него в следующем билете)

**Linux:**
- `top` — динамический просмотр загруженности системы.
- `vmstat` — мониторинг основной памяти.
- `iostat` — мониторинг дисковой активности.
- `mpstat` — мониторинг работы процессора.

##### Мониторинг сети:

**Windows:**
- `ipconfig` — просмотр информации об интерфейсах компьютера.
- `ping` — проверка доступности удалённого узла и измерение времени отклика.
- `tracert` — трассировка маршрута до хоста.
- `netstat` — информация о портах, соединениях, сокетах.
- `nslookup` — проверка DNS-резолвинга.
- `arp -a` — просмотр ARP-таблицы.

Linux:
- `ip addr` — просмотр IP-адресов и интерфейсов.
- `ip route` — просмотр таблицы маршрутизации.
- `ping` — проверка доступности удалённого узла и измерение времени отклика.
- `traceroute` — трассировка маршрута до хоста.
- `netstat` — информация о портах, соединениях, сокетах.
- `nslookup` — проверка DNS-резолвинга.
- `arp` — просмотр ARP-таблицы.

##### Инструменты оптимизации:

**Windows:**
- Autoruns — управление автозагрузкой.
- MSConfig — настройка служб системы.
**Linux:**
- systemctl — настройка служб системы.
- cron — планирование задач для автоматизации.

#### 85. Оснастка «Производительность» (Performance) и ее инструменты системный монитор (System Monitor Control) и журналы производительности (Performance Logs end Alerts). Работа с оснасткой.

**Оснастка «Производительность»** — это модуль Microsoft Management Console (MMC), который предоставляет доступ к инструментам для мониторинга и оптимизации системы.
Основными компонентами являются:
- **System Monitor Control** — позволяет просматривать данные о производительности в реальном времени (как диспетчер задач).
- **Performance Logs and Alerts** — позволяет создавать журналы данных производительности для последующего анализа. Также можно установить оповещение о том, что какой-то параметр вышел за указанные пределы.

Чтобы открыть утилиту, нужно ввести в командной строке `perfmon`. Это мощный инструмент, позволяющий не только просматривать текущую загрузку, но и, например, записывать её в файл, для дальнейшего анализа за более продолжительный срок.

Чтобы лучше понять что это такое, рекомендую самостоятельно потыкать. Win + R и ввести `perfmon`.
![[perfmon.png]]

#### 86. Оснастка «Просмотр событий» (event Viewer). Журналы счетчиков и трассировки. Оповещения. Типы и параметры событий. Просмотр журналов и настройка его параметров.

##### Просмотр событий:

**Просмотр событий** — это встроенная оснастка Windows, предназначенная для просмотра, анализа и управления журналами событий, которые записываются системой и приложениями.

Журналы событий — это записи значимых событий, происходящих в системе. Основные типы журналов:

- **Application** — события, связанные с установленными приложениями.
- **Security** — события, связанные с безопасностью, такие как попытки входа и изменения прав пользователей.
- **System** — события, связанные с операционной системой и оборудованием.
- **Setup** — события, связанные с установкой и обновлением системы.
- **Forwarded Events** — события, пересланные с других компьютеров.

##### Журналы счетчиков, трассировки и оповещения:

**Журналы счётчиков и трассировки** относятся создаются через оснастку "Производительность". Они ведут записи производительности, такие как использование процессора, памяти и диска. Также могут генерировать события в Event Viewer (там хранятся различные системные события, ошибки, уведомления), например, если какой-то параметр превышает установленную норму.

**Трассировки** — инструмент для логирования системных событий.

**Оповещения** — уведомления, которые прикреплены к определённому событию. Можно назначить задачу, которая будет выполняться при появлении в Event Viewer. Этой задачей может быть отображение уведомления.

##### Типы и параметры событий:

**Типы:**
- **Error** — указывает на серьезную проблему, требующую внимания.
- **Warning** — указывает на потенциальную проблему, которая может не быть критичной, но требует проверки.
- **Information** — общая информация о системе или приложениях.
- **Success Audit** — успешные события аудита безопасности, например, успешные попытки входа.
- **Failure Audit** — неудачные события аудита безопасности, например, неудачные попытки входа.

**Параметры:**
- **Level** — уровень серьезности (Information, Warning, Error, Critical).
- **Date and Time** — дата и время события.
- **Source** — источник события (приложение или служба).
- **Event ID** — уникальный идентификатор события, например, 4624 для успешного входа или 4625 для неудачной попытки.
- **Task Category** — дополнительная классификация события.
- **Description** — подробное описание события.

##### Просмотр событий и настройка событий:

Для просмотра журнала событий необходимо ввести `eventvwr` в консоль или "Просмотр событий" в поиск Windows.

При открытии можно будет выбрать необходимый тип события. Там же можно и изменить параметры журналирования.

#### 87. Основные объекты мониторинга: оперативная память, процессоры, дисковая подсистема, сетевые платы и драйверы. Методика устранение «узких мест».

Методы мониторинга различных компонентов системы были описаны ранее.

##### Драйверы:

**Windows:**
- Диспетчер устройств — показывает список устройств и их характеристики (в том числе и драйвера).
**Linux:**
- `lsmod` — показывает загруженные модули ядра (драйверы).
- `dmesg` — логи системных сообщений, включая ошибки драйверов.
- `modinfo` — информация о конкретном драйвере.

##### Методика устранения "узких мест":

**Методика устранения узких мест** — это последовательный процесс выявления и устранения компонентов системы, ограничивающих её общую производительность. Она основана на систематическом мониторинге, анализе и оптимизации ресурсов.

Через инструменты мониторинга можно проанализировать состояние системы и выяснить, какой из компонентов плохо справляется. Основываясь на этих данных можно принять решение о необходимости обновления комплектующих ПК.