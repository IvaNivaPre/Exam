
Существуют процессы, ограниченные скоростью вычислений и работой устройств ввода-вывода.

Есть 2 вида алгоритмов планирования: **приоритетный** (ограниченный временем) и **неприоритетный**. Васильев привёл другую терминологию: вытесняющее и невытесняющее планирование.

При **невытесняющем** планировании процесс выполняется пока он сам не отдаст управление планировщику.

При **вытесняющем** планировании решение о переключении процесса с одного на другой принимается планировщиком.

## Пакетные системы

Нет пользователей, которые ждали бы быстродействия, поэтому, в целом, там длинные процессы. Много вычислений с небольшим количеством прерываний.

## Интерактивные системы

Есть процессы, на которые нужно иметь быструю реакцию. Из-за этого процессы и элементы выполняются быстро. Нужно удовлетворять пользователя.

## Системы реального времени

Системы, в которых необходимо моментально реагировать на некоторые сигналы. Задачи могут планироваться на этапе запуска или динамически. Различают **жёсткие** и **мягкие** системы.

## Алгоритмы планирования

### FIFO (First In, First Out)

Самый простой алгоритм. Простая очередь. Этот способ несправедлив.

### Кратчайшая оставшаяся работа

Выполнение самого короткого задания (или задания, у которого осталось меньше всего делать — если оно было прервано).  
Метод уменьшает среднее время ожидания процесса для начала выполнения.  
Неполные данные можно получать, опираясь на предыдущие выполнения.

### Увеличение алгоритма (Round-Robin)

Всем процессам выделяется одинаковое количество квантов.  
Каждый процесс выполняется по очереди, не имея приоритета.  
Каждый процесс получает одинаковое количество процессорного времени.

- Если кванты большие, алгоритм похож на FIFO.
- Если кванты маленькие, возрастает накладной расход на переключение контекста.

### Приоритетное планирование

Каждому процессу присваивается числовой приоритет, соответствующий какой-либо характеристике.  
Проблема метода — **голодание (starvation)**: процессы с низким приоритетом практически не получают времени.
Решение — повышение приоритета "старых" процессов (или понижение "прожорливых").

Такой подход называется **планирование по остаточному отношению**. Приоритет при таком подходе вычисляется по формуле:

$\Huge prioity = \frac{time\,+\,service}{service\,time}$

### Многоуровневая очередь

Процессы группируются по характеристикам (системные, интерактивные, фоновые и т.д.).  
Каждой группе присваивается приоритет.  
Система выбирает группу с наивысшим приоритетом и применяет алгоритм внутри группы.  
Алгоритмы могут различаться между группами.

Такой подход эффективен, но возможна проблема starvation.  
Решение — **многоуровневая очередь с обратной связью**, где процессы могут перемещаться между группами в зависимости от их поведения.


### Вероятностное планирование (Lottery scheduling) 

Каждому процессу присваивается некоторый номер, а планировщик случайным образом выбирает номер процесса, который будет выполняться следующим. Такой способ решает проблему старвации.