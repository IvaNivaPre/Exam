

В оперативной памяти невозможно одновременно разместить сразу все процессы. Из-за этого возникает необходимость в использовании виртуальных адресов. Те части программы, которые не используются в данный момент, выгружаются на диск и не занимают ОЗУ.

#### Фрагментация

**Внутренняя фрагментация** — выделение памяти под процесс с большим объемом, чем ему требуется.

![[Internal Fragmentation.png]]

**Внешняя фрагментация** — память делится на множество мелких блоков, среди которых сложно найти большой, непрерывный для выделения процессу.

![[External fragmentation.png]]

#### Сегментное выделение памяти

**Фиксированные разделы (Fixed Partitioning)** — память делится на фиксированное количество блоков фиксированного размера при запуске системы. Каждый блок выделяется отдельному процессу (если одного блока не хватает для процесса, память просто не выделится). При таком подходе отсутствует внешняя фрагментация, зато сильно распространена внутренняя.

**Динамические разделы (Dynamic Partitioning)** — память делится на блоки переменного размера в зависимости от потребностей процессов. Блоки создаются и удаляются динамически. Это минимизирует внутреннюю фрагментацию, но может возникнуть внешняя. Как раз здесь используются алгоритмы распределения памяти.

При данном подходе у каждого процесса появляется базовый адрес и предел.
`Физический адрес` = `виртуальный адрес` + `базовый адрес`.
![[Segments.png]]
Если получившийся адрес выходит за предел, то возникает исключение.

Эти сегменты могут выгружаться на диск в случае неактивности и загружаться обратно, если нужно. Такой процесс называется свопингом. Он сильно бьёт по производительности.

#### Paging

Вся память делится на страницы. Они могут быть разного размера (основные размеры: 4Кб; 2Мб; 1Гб). Страницы, находящиеся в физической памяти, называются страничными блоками. Информация о размещении виртуальных страниц находится в специальной таблице, ключами которой является номер виртуальной страницы, а значением — смещение, с которым нужно обращаться к физ. памяти.
Скажем, виртуальный адрес состоит из 16 бит. Первые 4 бита будут отображать номер виртуальной страницы и, а оставшиеся 12 бит — адрес, по которому обращаются к ячейке.
На вход таблицы поднимается 16-битный виртуальный адрес, на выходе получается физ. адрес, путём замены 4 бит номера страницы, благодаря чему происходит смещение. Также в этой таблице, в которой для страницы существует бит присутствия. Если при обращении к таблице его нет, то произойдет Page fault, это будет означать, что страница не в физ. памяти и её нужно загрузить с диска.
Подобная структура утратила актуальность с внедрением 64-разрядных виртуальных адресов — многоуровневые таблицы.

Отображение виртуальных страниц на физическую память:
![[Vittual pages to phys mem.png]]


Такая структура необходима, чтобы страница загружалась в память, только если она необходима. В общем массиве нужно было выделить место под все страницы, а здесь, пока страница не будет востребована и загружена, директорий таблицы будут инициализированы и не будут занимать пространство на диске.

TLB — Translation Lookaside Buffer — буфер быстрого преобразования aka кэш. В нём сохраняются наиболее востребованные страницы (точнее их расположение в таблице страниц для более быстрого поиска). Обращение к TLB занимает в сотни раз меньше, чем к Page Table и в миллионы раз быстрее, чем к диску.

Обращение к MMU:
![[MMU actions.png]]

Вид многоуровневой таблицы страниц:
![[Page Table.png]]

Преобразование адресов:

![[Virtual --- Physical.png]]