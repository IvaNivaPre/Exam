
Это примитив синхронизации. Важно понимать, что он атомарен. Также он является аппаратной инструкцией процессора (это значит, что она написана на ассемблере, и приведённый ниже пример является скорее псевдокодом).

```
bool TestAndSet(bool* lock) {  // сама функция Test-and-Set
    bool old = *lock;
    *lock = true;
    return old;
}


bool lock = false;

void acquire_lock() {  // простая реализация мьютекса, при помощи Test-and-Set
    while (TestAndSet(&lock)) {
        // активное ожидание (busy-wait)
    }
}

void release_lock() {
    lock = false;
}

```

Примитив читает значение переданной переменной, запоминает его, меняет значение на `true` и возвращает старое. Так, если `lock = false` при запуске функции, произойдёт "захват" и вернётся `false` (это будет означать, что захват успешен). Если `lock = true`, то функция просто вернёт `true` (значит, что захват не удался).